{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/bullet-list/bullet-list.ts\nimport { mergeAttributes, Node, wrappingInputRule } from \"@tiptap/core\";\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{\n      tag: \"ul\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"ul\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || token.ordered) {\n      return [];\n    }\n    return {\n      type: \"bulletList\",\n      content: token.items ? helpers.parseChildren(token.items) : []\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({\n        commands,\n        chain\n      }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\nimport { mergeAttributes as mergeAttributes2, Node as Node2, renderNestedMarkdownContent } from \"@tiptap/core\";\nvar ListItem = Node2.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [{\n      tag: \"li\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"li\", mergeAttributes2(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list_item\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list_item\") {\n      return [];\n    }\n    let content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      const hasParagraphTokens = token.tokens.some(t => t.type === \"paragraph\");\n      if (hasParagraphTokens) {\n        content = helpers.parseChildren(token.tokens);\n      } else {\n        const firstToken = token.tokens[0];\n        if (firstToken && firstToken.type === \"text\" && firstToken.tokens && firstToken.tokens.length > 0) {\n          const inlineContent = helpers.parseInline(firstToken.tokens);\n          content = [{\n            type: \"paragraph\",\n            content: inlineContent\n          }];\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1);\n            const additionalContent = helpers.parseChildren(remainingTokens);\n            content.push(...additionalContent);\n          }\n        } else {\n          content = helpers.parseChildren(token.tokens);\n        }\n      }\n    }\n    if (content.length === 0) {\n      content = [{\n        type: \"paragraph\",\n        content: []\n      }];\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  },\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(node, h, context => {\n      if (context.parentType === \"bulletList\") {\n        return \"- \";\n      }\n      if (context.parentType === \"orderedList\") {\n        return `${context.index + 1}. `;\n      }\n      return \"- \";\n    }, ctx);\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\nimport { Extension } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\nimport { getNodeType } from \"@tiptap/core\";\nvar findListItemPos = (typeOrName, state) => {\n  const {\n    $from\n  } = state.selection;\n  const nodeType = getNodeType(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return {\n    $pos: state.doc.resolve(currentPos),\n    depth: targetDepth\n  };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\nimport { getNodeAtPosition } from \"@tiptap/core\";\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nimport { isAtStartOfNode, isNodeActive } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const {\n    $anchor\n  } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const {\n    $anchor\n  } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\nimport { getNodeType as getNodeType2 } from \"@tiptap/core\";\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = getNodeType2(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const {\n      $anchor\n    } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({\n          node,\n          pos\n        });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({\n      from: $anchor.start() - 1,\n      to: $anchor.end() + 1\n    }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!isNodeActive(editor.state, name)) {\n    return false;\n  }\n  if (!isAtStartOfNode(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nimport { isAtEndOfNode, isNodeActive as isNodeActive2 } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!isNodeActive2(editor.state, name)) {\n    return false;\n  }\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false;\n  }\n  const {\n    selection\n  } = editor.state;\n  const {\n    $from,\n    $to\n  } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const {\n    $anchor\n  } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [{\n        itemName: \"listItem\",\n        wrapperNames: [\"bulletList\", \"orderedList\"]\n      }, {\n        itemName: \"taskItem\",\n        wrapperNames: [\"taskList\"]\n      }]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName,\n          wrapperNames\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName,\n          wrapperNames\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\nimport { Extension as Extension2 } from \"@tiptap/core\";\n\n// src/ordered-list/ordered-list.ts\nimport { mergeAttributes as mergeAttributes3, Node as Node3, wrappingInputRule as wrappingInputRule2 } from \"@tiptap/core\";\n\n// src/ordered-list/utils.ts\nvar ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/;\nvar INDENTED_LINE_REGEX = /^\\s/;\nfunction collectOrderedListItems(lines) {\n  const listItems = [];\n  let currentLineIndex = 0;\n  let consumed = 0;\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex];\n    const match = line.match(ORDERED_LIST_ITEM_REGEX);\n    if (!match) {\n      break;\n    }\n    const [, indent, number, content] = match;\n    const indentLevel = indent.length;\n    let itemContent = content;\n    let nextLineIndex = currentLineIndex + 1;\n    const itemLines = [line];\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex];\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);\n      if (nextMatch) {\n        break;\n      }\n      if (nextLine.trim() === \"\") {\n        itemLines.push(nextLine);\n        itemContent += \"\\n\";\n        nextLineIndex += 1;\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        itemLines.push(nextLine);\n        itemContent += `\n${nextLine.slice(indentLevel + 2)}`;\n        nextLineIndex += 1;\n      } else {\n        break;\n      }\n    }\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join(\"\\n\")\n    });\n    consumed = nextLineIndex;\n    currentLineIndex = nextLineIndex;\n  }\n  return [listItems, consumed];\n}\nfunction buildNestedStructure(items, baseIndent, lexer) {\n  var _a;\n  const result = [];\n  let currentIndex = 0;\n  while (currentIndex < items.length) {\n    const item = items[currentIndex];\n    if (item.indent === baseIndent) {\n      const contentLines = item.content.split(\"\\n\");\n      const mainText = ((_a = contentLines[0]) == null ? void 0 : _a.trim()) || \"\";\n      const tokens = [];\n      if (mainText) {\n        tokens.push({\n          type: \"paragraph\",\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText)\n        });\n      }\n      const additionalContent = contentLines.slice(1).join(\"\\n\").trim();\n      if (additionalContent) {\n        const blockTokens = lexer.blockTokens(additionalContent);\n        tokens.push(...blockTokens);\n      }\n      let lookAheadIndex = currentIndex + 1;\n      const nestedItems = [];\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex]);\n        lookAheadIndex += 1;\n      }\n      if (nestedItems.length > 0) {\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent));\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);\n        tokens.push({\n          type: \"list\",\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join(\"\\n\")\n        });\n      }\n      result.push({\n        type: \"list_item\",\n        raw: item.raw,\n        tokens\n      });\n      currentIndex = lookAheadIndex;\n    } else {\n      currentIndex += 1;\n    }\n  }\n  return result;\n}\nfunction parseListItems(items, helpers) {\n  return items.map(item => {\n    if (item.type !== \"list_item\") {\n      return helpers.parseChildren([item])[0];\n    }\n    const content = [];\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        if (itemToken.type === \"paragraph\" || itemToken.type === \"list\" || itemToken.type === \"blockquote\" || itemToken.type === \"code\") {\n          content.push(...helpers.parseChildren([itemToken]));\n        } else if (itemToken.type === \"text\" && itemToken.tokens) {\n          const inlineContent = helpers.parseChildren([itemToken]);\n          content.push({\n            type: \"paragraph\",\n            content: inlineContent\n          });\n        } else {\n          const parsed = helpers.parseChildren([itemToken]);\n          if (parsed.length > 0) {\n            content.push(...parsed);\n          }\n        }\n      });\n    }\n    return {\n      type: \"listItem\",\n      content\n    };\n  });\n}\n\n// src/ordered-list/ordered-list.ts\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = Node3.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"ol\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    const {\n      start,\n      ...attributesWithoutStart\n    } = HTMLAttributes;\n    return start === 1 ? [\"ol\", mergeAttributes3(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", mergeAttributes3(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  markdownTokenName: \"list\",\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== \"list\" || !token.ordered) {\n      return [];\n    }\n    const startValue = token.start || 1;\n    const content = token.items ? parseListItems(token.items, helpers) : [];\n    if (startValue !== 1) {\n      return {\n        type: \"orderedList\",\n        attrs: {\n          start: startValue\n        },\n        content\n      };\n    }\n    return {\n      type: \"orderedList\",\n      content\n    };\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"orderedList\",\n    level: \"block\",\n    start: src => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/);\n      const index = match == null ? void 0 : match.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize: (src, _tokens, lexer) => {\n      var _a;\n      const lines = src.split(\"\\n\");\n      const [listItems, consumed] = collectOrderedListItems(lines);\n      if (listItems.length === 0) {\n        return void 0;\n      }\n      const items = buildNestedStructure(listItems, 0, lexer);\n      if (items.length === 0) {\n        return void 0;\n      }\n      const startValue = ((_a = listItems[0]) == null ? void 0 : _a.number) || 1;\n      return {\n        type: \"list\",\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join(\"\\n\")\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({\n        commands,\n        chain\n      }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = wrappingInputRule2({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        start: +match[1]\n      }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule2({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({\n          start: +match[1],\n          ...this.editor.getAttributes(TextStyleName2)\n        }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\nimport { mergeAttributes as mergeAttributes4, Node as Node4, renderNestedMarkdownContent as renderNestedMarkdownContent2, wrappingInputRule as wrappingInputRule3 } from \"@tiptap/core\";\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = Node4.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: attributes => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: `li[data-type=\"${this.name}\"]`,\n      priority: 51\n    }];\n  },\n  renderHTML({\n    node,\n    HTMLAttributes\n  }) {\n    return [\"li\", mergeAttributes4(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-type\": this.name\n    }), [\"label\", [\"input\", {\n      type: \"checkbox\",\n      checked: node.attrs.checked ? \"checked\" : null\n    }], [\"span\"]], [\"div\", 0]];\n  },\n  parseMarkdown: (token, h) => {\n    const content = [];\n    if (token.tokens && token.tokens.length > 0) {\n      content.push(h.createNode(\"paragraph\", {}, h.parseInline(token.tokens)));\n    } else if (token.text) {\n      content.push(h.createNode(\"paragraph\", {}, [h.createNode(\"text\", {\n        text: token.text\n      })]));\n    } else {\n      content.push(h.createNode(\"paragraph\", {}, []));\n    }\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens);\n      content.push(...nestedContent);\n    }\n    return h.createNode(\"taskItem\", {\n      checked: token.checked || false\n    }, content);\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    const checkedChar = ((_a = node.attrs) == null ? void 0 : _a.checked) ? \"x\" : \" \";\n    const prefix = `- [${checkedChar}] `;\n    return renderNestedMarkdownContent2(node, h, prefix);\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return ({\n      node,\n      HTMLAttributes,\n      getPos,\n      editor\n    }) => {\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = currentNode => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n      };\n      updateA11Y(node);\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", event => event.preventDefault());\n      checkbox.addEventListener(\"change\", event => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const {\n          checked\n        } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, {\n            scrollIntoView: false\n          }).command(({\n            tr\n          }) => {\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...(currentNode == null ? void 0 : currentNode.attrs),\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y(updatedNode);\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [wrappingInputRule3({\n      find: inputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        checked: match[match.length - 1] === \"x\"\n      })\n    })];\n  }\n});\n\n// src/task-list/task-list.ts\nimport { mergeAttributes as mergeAttributes5, Node as Node5, parseIndentedBlocks } from \"@tiptap/core\";\nvar TaskList = Node5.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{\n      tag: `ul[data-type=\"${this.name}\"]`,\n      priority: 51\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"ul\", mergeAttributes5(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-type\": this.name\n    }), 0];\n  },\n  parseMarkdown: (token, h) => {\n    return h.createNode(\"taskList\", {}, h.parseChildren(token.items || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    return h.renderChildren(node.content, \"\\n\");\n  },\n  markdownTokenizer: {\n    name: \"taskList\",\n    level: \"block\",\n    start(src) {\n      var _a;\n      const index = (_a = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)) == null ? void 0 : _a.index;\n      return index !== void 0 ? index : -1;\n    },\n    tokenize(src, tokens, lexer) {\n      const parseTaskListContent = content => {\n        const nestedResult = parseIndentedBlocks(content, {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === \"x\"\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: \"taskItem\",\n            raw: \"\",\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens\n          }),\n          // Allow recursive nesting\n          customNestedParser: parseTaskListContent\n        }, lexer);\n        if (nestedResult) {\n          return [{\n            type: \"taskList\",\n            raw: nestedResult.raw,\n            items: nestedResult.items\n          }];\n        }\n        return lexer.blockTokens(content);\n      };\n      const result = parseIndentedBlocks(src, {\n        itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n        extractItemData: match => ({\n          indentLevel: match[1].length,\n          mainContent: match[4],\n          checked: match[3].toLowerCase() === \"x\"\n        }),\n        createToken: (data, nestedTokens) => ({\n          type: \"taskItem\",\n          raw: \"\",\n          mainContent: data.mainContent,\n          indentLevel: data.indentLevel,\n          checked: data.checked,\n          text: data.mainContent,\n          tokens: lexer.inlineTokens(data.mainContent),\n          nestedTokens\n        }),\n        // Use the recursive parser for nested content\n        customNestedParser: parseTaskListContent\n      }, lexer);\n      if (!result) {\n        return void 0;\n      }\n      return {\n        type: \"taskList\",\n        raw: result.raw,\n        items: result.items\n      };\n    }\n  },\n  markdownOptions: {\n    indentsContent: true\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => ({\n        commands\n      }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = Extension2.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\nexport { BulletList, ListItem, ListKeymap, ListKit, OrderedList, TaskItem, TaskList, bulletListInputRegex, inputRegex, listHelpers_exports as listHelpers, orderedListInputRegex };","map":{"version":3,"names":["mergeAttributes","Node","wrappingInputRule","ListItemName","TextStyleName","bulletListInputRegex","BulletList","create","name","addOptions","itemTypeName","HTMLAttributes","keepMarks","keepAttributes","group","content","options","parseHTML","tag","renderHTML","markdownTokenName","parseMarkdown","token","helpers","type","ordered","items","parseChildren","renderMarkdown","node","h","renderChildren","markdownOptions","indentsContent","addCommands","toggleBulletList","commands","chain","toggleList","updateAttributes","editor","getAttributes","run","addKeyboardShortcuts","Mod-Shift-8","addInputRules","inputRule","find","mergeAttributes2","Node2","renderNestedMarkdownContent","ListItem","bulletListTypeName","orderedListTypeName","defining","tokens","length","hasParagraphTokens","some","t","firstToken","inlineContent","parseInline","remainingTokens","slice","additionalContent","push","ctx","context","parentType","index","Enter","splitListItem","Tab","sinkListItem","Shift-Tab","liftListItem","Extension","listHelpers_exports","__export","findListItemPos","getNextListDepth","handleBackspace","handleDelete","hasListBefore","hasListItemAfter","hasListItemBefore","listItemHasSubList","nextListIsDeeper","nextListIsHigher","getNodeType","typeOrName","state","$from","selection","nodeType","schema","currentNode","currentDepth","depth","currentPos","pos","targetDepth","$pos","doc","resolve","getNodeAtPosition","listItemPos","isAtStartOfNode","isNodeActive","editorState","parentListTypes","$anchor","previousNodePos","Math","max","previousNode","includes","_a","$targetPos","nodeBefore","getNodeType2","hasSubList","descendants","child","undoInputRule","from","to","$listPos","before","listDescendants","lastItem","at","$lastItemPos","start","cut","end","joinForward","$prev","prevNode","previousListItemHasSubList","joinItemBackward","isAtEndOfNode","isNodeActive2","listDepth","$to","empty","sameParent","focus","lift","joinBackward","joinItemForward","parentOffset","parent","childCount","nodeAfter","ListKeymap","listTypes","itemName","wrapperNames","Delete","handled","forEach","nodes","Mod-Delete","Backspace","Mod-Backspace","Extension2","mergeAttributes3","Node3","wrappingInputRule2","ORDERED_LIST_ITEM_REGEX","INDENTED_LINE_REGEX","collectOrderedListItems","lines","listItems","currentLineIndex","consumed","line","match","indent","number","indentLevel","itemContent","nextLineIndex","itemLines","nextLine","nextMatch","trim","parseInt","raw","join","buildNestedStructure","baseIndent","lexer","result","currentIndex","item","contentLines","split","mainText","inlineTokens","blockTokens","lookAheadIndex","nestedItems","nextIndent","min","map","nestedItem","nestedListItems","parseListItems","itemToken","parsed","ListItemName2","TextStyleName2","orderedListInputRegex","OrderedList","addAttributes","default","element","hasAttribute","getAttribute","attributesWithoutStart","startValue","attrs","markdownTokenizer","level","src","tokenize","_tokens","toggleOrderedList","Mod-Shift-7","joinPredicate","mergeAttributes4","Node4","renderNestedMarkdownContent2","wrappingInputRule3","inputRegex","TaskItem","nested","taskListTypeName","a11y","checked","keepOnSplit","dataChecked","attributes","priority","createNode","text","nestedTokens","nestedContent","checkedChar","prefix","shortcuts","addNodeView","getPos","listItem","document","createElement","checkboxWrapper","checkboxStyler","checkbox","updateA11Y","_b","ariaLabel","checkboxLabel","call","textContent","contentEditable","addEventListener","event","preventDefault","isEditable","onReadOnlyChecked","target","scrollIntoView","command","tr","position","nodeAt","setNodeMarkup","Object","entries","key","value","setAttribute","dataset","append","dom","contentDOM","update","updatedNode","mergeAttributes5","Node5","parseIndentedBlocks","TaskList","parseTaskListContent","nestedResult","itemPattern","extractItemData","mainContent","toLowerCase","createToken","data","customNestedParser","toggleTaskList","Mod-Shift-9","ListKit","addExtensions","extensions","bulletList","configure","listKeymap","orderedList","taskItem","taskList"],"sources":["../src/bullet-list/bullet-list.ts","../src/item/list-item.ts","../src/keymap/list-keymap.ts","../src/keymap/listHelpers/index.ts","../src/keymap/listHelpers/findListItemPos.ts","../src/keymap/listHelpers/getNextListDepth.ts","../src/keymap/listHelpers/handleBackspace.ts","../src/keymap/listHelpers/hasListBefore.ts","../src/keymap/listHelpers/hasListItemBefore.ts","../src/keymap/listHelpers/listItemHasSubList.ts","../src/keymap/listHelpers/handleDelete.ts","../src/keymap/listHelpers/nextListIsDeeper.ts","../src/keymap/listHelpers/nextListIsHigher.ts","../src/keymap/listHelpers/hasListItemAfter.ts","../src/kit/index.ts","../src/ordered-list/ordered-list.ts","../src/ordered-list/utils.ts","../src/task-item/task-item.ts","../src/task-list/task-list.ts"],"sourcesContent":["import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || (token as any).ordered) {\n      return []\n    }\n\n    return {\n      type: 'bulletList',\n      content: token.items ? helpers.parseChildren(token.items) : [],\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import { mergeAttributes, Node, renderNestedMarkdownContent } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list_item',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list_item') {\n      return []\n    }\n\n    let content: any[] = []\n\n    if (token.tokens && token.tokens.length > 0) {\n      // Check if we have paragraph tokens (complex list items)\n      const hasParagraphTokens = token.tokens.some(t => t.type === 'paragraph')\n\n      if (hasParagraphTokens) {\n        // If we have paragraph tokens, parse them as block elements\n        content = helpers.parseChildren(token.tokens)\n      } else {\n        // Check if the first token is a text token with nested inline tokens\n        const firstToken = token.tokens[0]\n\n        if (firstToken && firstToken.type === 'text' && firstToken.tokens && firstToken.tokens.length > 0) {\n          // Parse the inline content from the text token\n          const inlineContent = helpers.parseInline(firstToken.tokens)\n\n          // Start with the paragraph containing the inline content\n          content = [\n            {\n              type: 'paragraph',\n              content: inlineContent,\n            },\n          ]\n\n          // If there are additional tokens after the first text token (like nested lists),\n          // parse them as block elements and add them\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1)\n            const additionalContent = helpers.parseChildren(remainingTokens)\n            content.push(...additionalContent)\n          }\n        } else {\n          // Fallback: parse all tokens as block elements\n          content = helpers.parseChildren(token.tokens)\n        }\n      }\n    }\n\n    // Ensure we always have at least an empty paragraph\n    if (content.length === 0) {\n      content = [\n        {\n          type: 'paragraph',\n          content: [],\n        },\n      ]\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(\n      node,\n      h,\n      (context: any) => {\n        if (context.parentType === 'bulletList') {\n          return '- '\n        }\n        if (context.parentType === 'orderedList') {\n          return `${context.index + 1}. `\n        }\n        // Fallback to bullet list for unknown parent types\n        return '- '\n      },\n      ctx,\n    )\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n","import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n","export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n","import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n","import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * Its a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n","import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nimport { buildNestedStructure, collectOrderedListItems, parseListItems } from './utils.js'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || !token.ordered) {\n      return []\n    }\n\n    const startValue = token.start || 1\n    const content = token.items ? parseListItems(token.items, helpers) : []\n\n    if (startValue !== 1) {\n      return {\n        type: 'orderedList',\n        attrs: { start: startValue },\n        content,\n      }\n    }\n\n    return {\n      type: 'orderedList',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'orderedList',\n    level: 'block',\n    start: (src: string) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/)\n      const index = match?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize: (src: string, _tokens, lexer) => {\n      const lines = src.split('\\n')\n      const [listItems, consumed] = collectOrderedListItems(lines)\n\n      if (listItems.length === 0) {\n        return undefined\n      }\n\n      const items = buildNestedStructure(listItems, 0, lexer)\n\n      if (items.length === 0) {\n        return undefined\n      }\n\n      const startValue = listItems[0]?.number || 1\n\n      return {\n        type: 'list',\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join('\\n'),\n      } as unknown as object\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import type { JSONContent, MarkdownLexerConfiguration, MarkdownParseHelpers, MarkdownToken } from '@tiptap/core'\n\n/**\n * Matches an ordered list item line with optional leading whitespace.\n * Captures: (1) indentation spaces, (2) item number, (3) content after marker\n * Example matches: \"1. Item\", \"  2. Nested item\", \"    3. Deeply nested\"\n */\nconst ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/\n\n/**\n * Matches any line that starts with whitespace (indented content).\n * Used to identify continuation content that belongs to a list item.\n */\nconst INDENTED_LINE_REGEX = /^\\s/\n\n/**\n * Represents a parsed ordered list item with indentation information\n */\nexport interface OrderedListItem {\n  indent: number\n  number: number\n  content: string\n  raw: string\n}\n\n/**\n * Collects all ordered list items from lines, parsing them into a flat array\n * with indentation information. Stops collecting continuation content when\n * encountering nested list items, allowing them to be processed separately.\n *\n * @param lines - Array of source lines to parse\n * @returns Tuple of [listItems array, number of lines consumed]\n */\nexport function collectOrderedListItems(lines: string[]): [OrderedListItem[], number] {\n  const listItems: OrderedListItem[] = []\n  let currentLineIndex = 0\n  let consumed = 0\n\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex]\n    const match = line.match(ORDERED_LIST_ITEM_REGEX)\n\n    if (!match) {\n      break\n    }\n\n    const [, indent, number, content] = match\n    const indentLevel = indent.length\n    let itemContent = content\n    let nextLineIndex = currentLineIndex + 1\n    const itemLines = [line]\n\n    // Collect continuation lines for this item (but NOT nested list items)\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex]\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX)\n\n      // If it's another list item (nested or not), stop collecting\n      if (nextMatch) {\n        break\n      }\n\n      // Check for continuation content (non-list content)\n      if (nextLine.trim() === '') {\n        // Empty line\n        itemLines.push(nextLine)\n        itemContent += '\\n'\n        nextLineIndex += 1\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        // Indented content - part of this item (but not a list item)\n        itemLines.push(nextLine)\n        itemContent += `\\n${nextLine.slice(indentLevel + 2)}` // Remove list marker indent\n        nextLineIndex += 1\n      } else {\n        // Non-indented line means end of list\n        break\n      }\n    }\n\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join('\\n'),\n    })\n\n    consumed = nextLineIndex\n    currentLineIndex = nextLineIndex\n  }\n\n  return [listItems, consumed]\n}\n\n/**\n * Recursively builds a nested structure from a flat array of list items\n * based on their indentation levels. Creates proper markdown tokens with\n * nested lists where appropriate.\n *\n * @param items - Flat array of list items with indentation info\n * @param baseIndent - The indentation level to process at this recursion level\n * @param lexer - Markdown lexer for parsing inline and block content\n * @returns Array of list_item tokens with proper nesting\n */\nexport function buildNestedStructure(\n  items: OrderedListItem[],\n  baseIndent: number,\n  lexer: MarkdownLexerConfiguration,\n): unknown[] {\n  const result: unknown[] = []\n  let currentIndex = 0\n\n  while (currentIndex < items.length) {\n    const item = items[currentIndex]\n\n    if (item.indent === baseIndent) {\n      // This item belongs at the current level\n      const contentLines = item.content.split('\\n')\n      const mainText = contentLines[0]?.trim() || ''\n\n      const tokens = []\n\n      // Always wrap the main text in a paragraph token\n      if (mainText) {\n        tokens.push({\n          type: 'paragraph',\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText),\n        })\n      }\n\n      // Handle additional content after the main text\n      const additionalContent = contentLines.slice(1).join('\\n').trim()\n      if (additionalContent) {\n        // Parse as block tokens (handles mixed unordered lists, etc.)\n        const blockTokens = lexer.blockTokens(additionalContent)\n        tokens.push(...blockTokens)\n      }\n\n      // Look ahead to find nested items at deeper indent levels\n      let lookAheadIndex = currentIndex + 1\n      const nestedItems = []\n\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex])\n        lookAheadIndex += 1\n      }\n\n      // If we have nested items, recursively build their structure\n      if (nestedItems.length > 0) {\n        // Find the next indent level (immediate children)\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent))\n\n        // Build the nested list recursively with all nested items\n        // The recursive call will handle further nesting\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer)\n\n        // Create a nested list token\n        tokens.push({\n          type: 'list',\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join('\\n'),\n        })\n      }\n\n      result.push({\n        type: 'list_item',\n        raw: item.raw,\n        tokens,\n      })\n\n      // Skip the nested items we just processed\n      currentIndex = lookAheadIndex\n    } else {\n      // This item has deeper indent than we're currently processing\n      // It should be handled by a recursive call\n      currentIndex += 1\n    }\n  }\n\n  return result\n}\n\n/**\n * Parses markdown list item tokens into Tiptap JSONContent structure,\n * ensuring text content is properly wrapped in paragraph nodes.\n *\n * @param items - Array of markdown tokens representing list items\n * @param helpers - Markdown parse helpers for recursive parsing\n * @returns Array of listItem JSONContent nodes\n */\nexport function parseListItems(items: MarkdownToken[], helpers: MarkdownParseHelpers): JSONContent[] {\n  return items.map(item => {\n    if (item.type !== 'list_item') {\n      return helpers.parseChildren([item])[0]\n    }\n\n    // Parse the tokens within the list item\n    const content: JSONContent[] = []\n\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        // If it's already a proper block node (paragraph, list, etc.), parse it directly\n        if (\n          itemToken.type === 'paragraph' ||\n          itemToken.type === 'list' ||\n          itemToken.type === 'blockquote' ||\n          itemToken.type === 'code'\n        ) {\n          content.push(...helpers.parseChildren([itemToken]))\n        } else if (itemToken.type === 'text' && itemToken.tokens) {\n          // If it's inline text tokens, wrap them in a paragraph\n          const inlineContent = helpers.parseChildren([itemToken])\n          content.push({\n            type: 'paragraph',\n            content: inlineContent,\n          })\n        } else {\n          // For any other content, try to parse it\n          const parsed = helpers.parseChildren([itemToken])\n          if (parsed.length > 0) {\n            content.push(...parsed)\n          }\n        }\n      })\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  })\n}\n","import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport { mergeAttributes, Node, renderNestedMarkdownContent, wrappingInputRule } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  parseMarkdown: (token, h) => {\n    // Parse the task item's text content into paragraph content\n    const content = []\n\n    // First, add the main paragraph content\n    if (token.tokens && token.tokens.length > 0) {\n      // If we have tokens, create a paragraph with the inline content\n      content.push(h.createNode('paragraph', {}, h.parseInline(token.tokens)))\n    } else if (token.text) {\n      // If we have raw text, create a paragraph with text node\n      content.push(h.createNode('paragraph', {}, [h.createNode('text', { text: token.text })]))\n    } else {\n      // Fallback: empty paragraph\n      content.push(h.createNode('paragraph', {}, []))\n    }\n\n    // Then, add any nested content (like nested task lists)\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens)\n      content.push(...nestedContent)\n    }\n\n    return h.createNode('taskItem', { checked: token.checked || false }, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    const checkedChar = node.attrs?.checked ? 'x' : ' '\n    const prefix = `- [${checkedChar}] `\n\n    return renderNestedMarkdownContent(node, h, prefix)\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isnt editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n","import { mergeAttributes, Node, parseIndentedBlocks } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.createNode('taskList', {}, h.parseChildren(token.items || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'taskList',\n    level: 'block',\n    start(src) {\n      // Look for the start of a task list item\n      const index = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize(src, tokens, lexer) {\n      // Helper function to recursively parse task lists\n      const parseTaskListContent = (content: string): any[] | undefined => {\n        const nestedResult = parseIndentedBlocks(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: match => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === 'x',\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: 'taskItem',\n              raw: '',\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens,\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent,\n          },\n          lexer,\n        )\n\n        if (nestedResult) {\n          // Return as task list token\n          return [\n            {\n              type: 'taskList',\n              raw: nestedResult.raw,\n              items: nestedResult.items,\n            },\n          ]\n        }\n\n        // Fall back to regular markdown parsing if not a task list\n        return lexer.blockTokens(content)\n      }\n\n      const result = parseIndentedBlocks(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === 'x',\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: 'taskItem',\n            raw: '',\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens,\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent,\n        },\n        lexer,\n      )\n\n      if (!result) {\n        return undefined\n      }\n\n      return {\n        type: 'taskList',\n        raw: result.raw,\n        items: result.items,\n      }\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n"],"mappings":";;;;;;;;;;;;;;AAAA,SAASA,eAAA,EAAiBC,IAAA,EAAMC,iBAAA,QAAyB;AAEzD,IAAMC,YAAA,GAAe;AACrB,IAAMC,aAAA,GAAgB;AA8Cf,IAAMC,oBAAA,GAAuB;AAQ7B,IAAMC,UAAA,GAAaL,IAAA,CAAKM,MAAA,CAA0B;EACvDC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLC,YAAA,EAAc;MACdC,cAAA,EAAgB,CAAC;MACjBC,SAAA,EAAW;MACXC,cAAA,EAAgB;IAClB;EACF;EAEAC,KAAA,EAAO;EAEPC,QAAA,EAAU;IACR,OAAO,GAAG,KAAKC,OAAA,CAAQN,YAAY;EACrC;EAEAO,UAAA,EAAY;IACV,OAAO,CAAC;MAAEC,GAAA,EAAK;IAAK,CAAC;EACvB;EAEAC,WAAW;IAAER;EAAe,GAAG;IAC7B,OAAO,CAAC,MAAMX,eAAA,CAAgB,KAAKgB,OAAA,CAAQL,cAAA,EAAgBA,cAAc,GAAG,CAAC;EAC/E;EAEAS,iBAAA,EAAmB;EAEnBC,aAAA,EAAeA,CAACC,KAAA,EAAOC,OAAA,KAAY;IACjC,IAAID,KAAA,CAAME,IAAA,KAAS,UAAWF,KAAA,CAAcG,OAAA,EAAS;MACnD,OAAO,EAAC;IACV;IAEA,OAAO;MACLD,IAAA,EAAM;MACNT,OAAA,EAASO,KAAA,CAAMI,KAAA,GAAQH,OAAA,CAAQI,aAAA,CAAcL,KAAA,CAAMI,KAAK,IAAI;IAC9D;EACF;EAEAE,cAAA,EAAgBA,CAACC,IAAA,EAAMC,CAAA,KAAM;IAC3B,IAAI,CAACD,IAAA,CAAKd,OAAA,EAAS;MACjB,OAAO;IACT;IAEA,OAAOe,CAAA,CAAEC,cAAA,CAAeF,IAAA,CAAKd,OAAA,EAAS,IAAI;EAC5C;EAEAiB,eAAA,EAAiB;IACfC,cAAA,EAAgB;EAClB;EAEAC,YAAA,EAAc;IACZ,OAAO;MACLC,gBAAA,EACEA,CAAA,KACA,CAAC;QAAEC,QAAA;QAAUC;MAAM,MAAM;QACvB,IAAI,KAAKrB,OAAA,CAAQH,cAAA,EAAgB;UAC/B,OAAOwB,KAAA,CAAM,EACVC,UAAA,CAAW,KAAK9B,IAAA,EAAM,KAAKQ,OAAA,CAAQN,YAAA,EAAc,KAAKM,OAAA,CAAQJ,SAAS,EACvE2B,gBAAA,CAAiBpC,YAAA,EAAc,KAAKqC,MAAA,CAAOC,aAAA,CAAcrC,aAAa,CAAC,EACvEsC,GAAA,CAAI;QACT;QACA,OAAON,QAAA,CAASE,UAAA,CAAW,KAAK9B,IAAA,EAAM,KAAKQ,OAAA,CAAQN,YAAA,EAAc,KAAKM,OAAA,CAAQJ,SAAS;MACzF;IACJ;EACF;EAEA+B,qBAAA,EAAuB;IACrB,OAAO;MACL,eAAeC,CAAA,KAAM,KAAKJ,MAAA,CAAOJ,QAAA,CAASD,gBAAA,CAAiB;IAC7D;EACF;EAEAU,cAAA,EAAgB;IACd,IAAIC,SAAA,GAAY5C,iBAAA,CAAkB;MAChC6C,IAAA,EAAM1C,oBAAA;MACNmB,IAAA,EAAM,KAAKA;IACb,CAAC;IAED,IAAI,KAAKR,OAAA,CAAQJ,SAAA,IAAa,KAAKI,OAAA,CAAQH,cAAA,EAAgB;MACzDiC,SAAA,GAAY5C,iBAAA,CAAkB;QAC5B6C,IAAA,EAAM1C,oBAAA;QACNmB,IAAA,EAAM,KAAKA,IAAA;QACXZ,SAAA,EAAW,KAAKI,OAAA,CAAQJ,SAAA;QACxBC,cAAA,EAAgB,KAAKG,OAAA,CAAQH,cAAA;QAC7B4B,aAAA,EAAeA,CAAA,KAAM;UACnB,OAAO,KAAKD,MAAA,CAAOC,aAAA,CAAcrC,aAAa;QAChD;QACAoC,MAAA,EAAQ,KAAKA;MACf,CAAC;IACH;IACA,OAAO,CAACM,SAAS;EACnB;AACF,CAAC;;;ACtJD,SAAS9C,eAAA,IAAAgD,gBAAA,EAAiB/C,IAAA,IAAAgD,KAAA,EAAMC,2BAAA,QAAmC;AA6B5D,IAAMC,QAAA,GAAWF,KAAA,CAAK1C,MAAA,CAAwB;EACnDC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLE,cAAA,EAAgB,CAAC;MACjByC,kBAAA,EAAoB;MACpBC,mBAAA,EAAqB;IACvB;EACF;EAEAtC,OAAA,EAAS;EAETuC,QAAA,EAAU;EAEVrC,UAAA,EAAY;IACV,OAAO,CACL;MACEC,GAAA,EAAK;IACP,EACF;EACF;EAEAC,WAAW;IAAER;EAAe,GAAG;IAC7B,OAAO,CAAC,MAAMqC,gBAAA,CAAgB,KAAKhC,OAAA,CAAQL,cAAA,EAAgBA,cAAc,GAAG,CAAC;EAC/E;EAEAS,iBAAA,EAAmB;EAEnBC,aAAA,EAAeA,CAACC,KAAA,EAAOC,OAAA,KAAY;IACjC,IAAID,KAAA,CAAME,IAAA,KAAS,aAAa;MAC9B,OAAO,EAAC;IACV;IAEA,IAAIT,OAAA,GAAiB,EAAC;IAEtB,IAAIO,KAAA,CAAMiC,MAAA,IAAUjC,KAAA,CAAMiC,MAAA,CAAOC,MAAA,GAAS,GAAG;MAE3C,MAAMC,kBAAA,GAAqBnC,KAAA,CAAMiC,MAAA,CAAOG,IAAA,CAAKC,CAAA,IAAKA,CAAA,CAAEnC,IAAA,KAAS,WAAW;MAExE,IAAIiC,kBAAA,EAAoB;QAEtB1C,OAAA,GAAUQ,OAAA,CAAQI,aAAA,CAAcL,KAAA,CAAMiC,MAAM;MAC9C,OAAO;QAEL,MAAMK,UAAA,GAAatC,KAAA,CAAMiC,MAAA,CAAO,CAAC;QAEjC,IAAIK,UAAA,IAAcA,UAAA,CAAWpC,IAAA,KAAS,UAAUoC,UAAA,CAAWL,MAAA,IAAUK,UAAA,CAAWL,MAAA,CAAOC,MAAA,GAAS,GAAG;UAEjG,MAAMK,aAAA,GAAgBtC,OAAA,CAAQuC,WAAA,CAAYF,UAAA,CAAWL,MAAM;UAG3DxC,OAAA,GAAU,CACR;YACES,IAAA,EAAM;YACNT,OAAA,EAAS8C;UACX,EACF;UAIA,IAAIvC,KAAA,CAAMiC,MAAA,CAAOC,MAAA,GAAS,GAAG;YAC3B,MAAMO,eAAA,GAAkBzC,KAAA,CAAMiC,MAAA,CAAOS,KAAA,CAAM,CAAC;YAC5C,MAAMC,iBAAA,GAAoB1C,OAAA,CAAQI,aAAA,CAAcoC,eAAe;YAC/DhD,OAAA,CAAQmD,IAAA,CAAK,GAAGD,iBAAiB;UACnC;QACF,OAAO;UAELlD,OAAA,GAAUQ,OAAA,CAAQI,aAAA,CAAcL,KAAA,CAAMiC,MAAM;QAC9C;MACF;IACF;IAGA,IAAIxC,OAAA,CAAQyC,MAAA,KAAW,GAAG;MACxBzC,OAAA,GAAU,CACR;QACES,IAAA,EAAM;QACNT,OAAA,EAAS;MACX,EACF;IACF;IAEA,OAAO;MACLS,IAAA,EAAM;MACNT;IACF;EACF;EAEAa,cAAA,EAAgBA,CAACC,IAAA,EAAMC,CAAA,EAAGqC,GAAA,KAAQ;IAChC,OAAOjB,2BAAA,CACLrB,IAAA,EACAC,CAAA,EACCsC,OAAA,IAAiB;MAChB,IAAIA,OAAA,CAAQC,UAAA,KAAe,cAAc;QACvC,OAAO;MACT;MACA,IAAID,OAAA,CAAQC,UAAA,KAAe,eAAe;QACxC,OAAO,GAAGD,OAAA,CAAQE,KAAA,GAAQ,CAAC;MAC7B;MAEA,OAAO;IACT,GACAH,GACF;EACF;EAEAxB,qBAAA,EAAuB;IACrB,OAAO;MACL4B,KAAA,EAAOA,CAAA,KAAM,KAAK/B,MAAA,CAAOJ,QAAA,CAASoC,aAAA,CAAc,KAAKhE,IAAI;MACzDiE,GAAA,EAAKA,CAAA,KAAM,KAAKjC,MAAA,CAAOJ,QAAA,CAASsC,YAAA,CAAa,KAAKlE,IAAI;MACtD,aAAamE,CAAA,KAAM,KAAKnC,MAAA,CAAOJ,QAAA,CAASwC,YAAA,CAAa,KAAKpE,IAAI;IAChE;EACF;AACF,CAAC;;;AC/ID,SAASqE,SAAA,QAAiB;;;ACA1B,IAAAC,mBAAA;AAAAC,QAAA,CAAAD,mBAAA;EAAAE,eAAA,EAAAA,CAAA,KAAAA,eAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA,gBAAA;EAAAC,eAAA,EAAAA,CAAA,KAAAA,eAAA;EAAAC,YAAA,EAAAA,CAAA,KAAAA,YAAA;EAAAC,aAAA,EAAAA,CAAA,KAAAA,aAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA,gBAAA;EAAAC,iBAAA,EAAAA,CAAA,KAAAA,iBAAA;EAAAC,kBAAA,EAAAA,CAAA,KAAAA,kBAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA,gBAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA;AAAA;;;ACAA,SAASC,WAAA,QAAmB;AAIrB,IAAMV,eAAA,GAAkBA,CAACW,UAAA,EAA+BC,KAAA,KAAuB;EACpF,MAAM;IAAEC;EAAM,IAAID,KAAA,CAAME,SAAA;EACxB,MAAMC,QAAA,GAAWL,WAAA,CAAYC,UAAA,EAAYC,KAAA,CAAMI,MAAM;EAErD,IAAIC,WAAA,GAAc;EAClB,IAAIC,YAAA,GAAeL,KAAA,CAAMM,KAAA;EACzB,IAAIC,UAAA,GAAaP,KAAA,CAAMQ,GAAA;EACvB,IAAIC,WAAA,GAA6B;EAEjC,OAAOJ,YAAA,GAAe,KAAKI,WAAA,KAAgB,MAAM;IAC/CL,WAAA,GAAcJ,KAAA,CAAMhE,IAAA,CAAKqE,YAAY;IAErC,IAAID,WAAA,CAAYzE,IAAA,KAASuE,QAAA,EAAU;MACjCO,WAAA,GAAcJ,YAAA;IAChB,OAAO;MACLA,YAAA,IAAgB;MAChBE,UAAA,IAAc;IAChB;EACF;EAEA,IAAIE,WAAA,KAAgB,MAAM;IACxB,OAAO;EACT;EAEA,OAAO;IAAEC,IAAA,EAAMX,KAAA,CAAMY,GAAA,CAAIC,OAAA,CAAQL,UAAU;IAAGD,KAAA,EAAOG;EAAY;AACnE;;;AC7BA,SAASI,iBAAA,QAAyB;AAK3B,IAAMzB,gBAAA,GAAmBA,CAACU,UAAA,EAAoBC,KAAA,KAAuB;EAC1E,MAAMe,WAAA,GAAc3B,eAAA,CAAgBW,UAAA,EAAYC,KAAK;EAErD,IAAI,CAACe,WAAA,EAAa;IAChB,OAAO;EACT;EAEA,MAAM,GAAGR,KAAK,IAAIO,iBAAA,CAAkBd,KAAA,EAAOD,UAAA,EAAYgB,WAAA,CAAYJ,IAAA,CAAKF,GAAA,GAAM,CAAC;EAE/E,OAAOF,KAAA;AACT;;;ACdA,SAASS,eAAA,EAAiBC,YAAA,QAAoB;;;ACCvC,IAAMzB,aAAA,GAAgBA,CAAC0B,WAAA,EAA0BtG,IAAA,EAAcuG,eAAA,KAA8B;EAClG,MAAM;IAAEC;EAAQ,IAAIF,WAAA,CAAYhB,SAAA;EAEhC,MAAMmB,eAAA,GAAkBC,IAAA,CAAKC,GAAA,CAAI,GAAGH,OAAA,CAAQX,GAAA,GAAM,CAAC;EAEnD,MAAMe,YAAA,GAAeN,WAAA,CAAYN,GAAA,CAAIC,OAAA,CAAQQ,eAAe,EAAEpF,IAAA,CAAK;EAEnE,IAAI,CAACuF,YAAA,IAAgB,CAACL,eAAA,CAAgBM,QAAA,CAASD,YAAA,CAAa5F,IAAA,CAAKhB,IAAI,GAAG;IACtE,OAAO;EACT;EAEA,OAAO;AACT;;;ACZO,IAAM8E,iBAAA,GAAoBA,CAACK,UAAA,EAAoBC,KAAA,KAAgC;EAFtF,IAAA0B,EAAA;EAGE,MAAM;IAAEN;EAAQ,IAAIpB,KAAA,CAAME,SAAA;EAE1B,MAAMyB,UAAA,GAAa3B,KAAA,CAAMY,GAAA,CAAIC,OAAA,CAAQO,OAAA,CAAQX,GAAA,GAAM,CAAC;EAEpD,IAAIkB,UAAA,CAAWjD,KAAA,CAAM,MAAM,GAAG;IAC5B,OAAO;EACT;EAEA,MAAIgD,EAAA,GAAAC,UAAA,CAAWC,UAAA,KAAX,gBAAAF,EAAA,CAAuB9F,IAAA,CAAKhB,IAAA,MAASmF,UAAA,EAAY;IACnD,OAAO;EACT;EAEA,OAAO;AACT;;;AChBA,SAASD,WAAA,IAAA+B,YAAA,QAAmB;AAIrB,IAAMlC,kBAAA,GAAqBA,CAACI,UAAA,EAAoBC,KAAA,EAAoB/D,IAAA,KAAgB;EACzF,IAAI,CAACA,IAAA,EAAM;IACT,OAAO;EACT;EAEA,MAAMkE,QAAA,GAAW0B,YAAA,CAAY9B,UAAA,EAAYC,KAAA,CAAMI,MAAM;EAErD,IAAI0B,UAAA,GAAa;EAEjB7F,IAAA,CAAK8F,WAAA,CAAYC,KAAA,IAAS;IACxB,IAAIA,KAAA,CAAMpG,IAAA,KAASuE,QAAA,EAAU;MAC3B2B,UAAA,GAAa;IACf;EACF,CAAC;EAED,OAAOA,UAAA;AACT;;;AHXO,IAAMxC,eAAA,GAAkBA,CAAC1C,MAAA,EAAgBhC,IAAA,EAAcuG,eAAA,KAA8B;EAE1F,IAAIvE,MAAA,CAAOJ,QAAA,CAASyF,aAAA,CAAc,GAAG;IACnC,OAAO;EACT;EAIA,IAAIrF,MAAA,CAAOoD,KAAA,CAAME,SAAA,CAAUgC,IAAA,KAAStF,MAAA,CAAOoD,KAAA,CAAME,SAAA,CAAUiC,EAAA,EAAI;IAC7D,OAAO;EACT;EAKA,IAAI,CAAClB,YAAA,CAAarE,MAAA,CAAOoD,KAAA,EAAOpF,IAAI,KAAK4E,aAAA,CAAc5C,MAAA,CAAOoD,KAAA,EAAOpF,IAAA,EAAMuG,eAAe,GAAG;IAC3F,MAAM;MAAEC;IAAQ,IAAIxE,MAAA,CAAOoD,KAAA,CAAME,SAAA;IAEjC,MAAMkC,QAAA,GAAWxF,MAAA,CAAOoD,KAAA,CAAMY,GAAA,CAAIC,OAAA,CAAQO,OAAA,CAAQiB,MAAA,CAAO,IAAI,CAAC;IAE9D,MAAMC,eAAA,GAAsD,EAAC;IAE7DF,QAAA,CAASnG,IAAA,CAAK,EAAE8F,WAAA,CAAY,CAAC9F,IAAA,EAAMwE,GAAA,KAAQ;MACzC,IAAIxE,IAAA,CAAKL,IAAA,CAAKhB,IAAA,KAASA,IAAA,EAAM;QAC3B0H,eAAA,CAAgBhE,IAAA,CAAK;UAAErC,IAAA;UAAMwE;QAAI,CAAC;MACpC;IACF,CAAC;IAED,MAAM8B,QAAA,GAAWD,eAAA,CAAgBE,EAAA,CAAG,EAAE;IAEtC,IAAI,CAACD,QAAA,EAAU;MACb,OAAO;IACT;IAEA,MAAME,YAAA,GAAe7F,MAAA,CAAOoD,KAAA,CAAMY,GAAA,CAAIC,OAAA,CAAQuB,QAAA,CAASM,KAAA,CAAM,IAAIH,QAAA,CAAS9B,GAAA,GAAM,CAAC;IAEjF,OAAO7D,MAAA,CACJH,KAAA,CAAM,EACNkG,GAAA,CAAI;MAAET,IAAA,EAAMd,OAAA,CAAQsB,KAAA,CAAM,IAAI;MAAGP,EAAA,EAAIf,OAAA,CAAQwB,GAAA,CAAI,IAAI;IAAE,GAAGH,YAAA,CAAaG,GAAA,CAAI,CAAC,EAC5EC,WAAA,CAAY,EACZ/F,GAAA,CAAI;EACT;EAIA,IAAI,CAACmE,YAAA,CAAarE,MAAA,CAAOoD,KAAA,EAAOpF,IAAI,GAAG;IACrC,OAAO;EACT;EAIA,IAAI,CAACoG,eAAA,CAAgBpE,MAAA,CAAOoD,KAAK,GAAG;IAClC,OAAO;EACT;EAEA,MAAMe,WAAA,GAAc3B,eAAA,CAAgBxE,IAAA,EAAMgC,MAAA,CAAOoD,KAAK;EAEtD,IAAI,CAACe,WAAA,EAAa;IAChB,OAAO;EACT;EAEA,MAAM+B,KAAA,GAAQlG,MAAA,CAAOoD,KAAA,CAAMY,GAAA,CAAIC,OAAA,CAAQE,WAAA,CAAYJ,IAAA,CAAKF,GAAA,GAAM,CAAC;EAC/D,MAAMsC,QAAA,GAAWD,KAAA,CAAM7G,IAAA,CAAK8E,WAAA,CAAYR,KAAK;EAE7C,MAAMyC,0BAAA,GAA6BrD,kBAAA,CAAmB/E,IAAA,EAAMgC,MAAA,CAAOoD,KAAA,EAAO+C,QAAQ;EAGlF,IAAIrD,iBAAA,CAAkB9E,IAAA,EAAMgC,MAAA,CAAOoD,KAAK,KAAK,CAACgD,0BAAA,EAA4B;IACxE,OAAOpG,MAAA,CAAOJ,QAAA,CAASyG,gBAAA,CAAiB;EAC1C;EAKA,OAAOrG,MAAA,CAAOH,KAAA,CAAM,EAAEuC,YAAA,CAAapE,IAAI,EAAEkC,GAAA,CAAI;AAC/C;;;AInFA,SAASoG,aAAA,EAAejC,YAAA,IAAAkC,aAAA,QAAoB;;;ACIrC,IAAMvD,gBAAA,GAAmBA,CAACG,UAAA,EAAoBC,KAAA,KAAuB;EAC1E,MAAMoD,SAAA,GAAY/D,gBAAA,CAAiBU,UAAA,EAAYC,KAAK;EACpD,MAAMe,WAAA,GAAc3B,eAAA,CAAgBW,UAAA,EAAYC,KAAK;EAErD,IAAI,CAACe,WAAA,IAAe,CAACqC,SAAA,EAAW;IAC9B,OAAO;EACT;EAEA,IAAIA,SAAA,GAAYrC,WAAA,CAAYR,KAAA,EAAO;IACjC,OAAO;EACT;EAEA,OAAO;AACT;;;ACbO,IAAMV,gBAAA,GAAmBA,CAACE,UAAA,EAAoBC,KAAA,KAAuB;EAC1E,MAAMoD,SAAA,GAAY/D,gBAAA,CAAiBU,UAAA,EAAYC,KAAK;EACpD,MAAMe,WAAA,GAAc3B,eAAA,CAAgBW,UAAA,EAAYC,KAAK;EAErD,IAAI,CAACe,WAAA,IAAe,CAACqC,SAAA,EAAW;IAC9B,OAAO;EACT;EAEA,IAAIA,SAAA,GAAYrC,WAAA,CAAYR,KAAA,EAAO;IACjC,OAAO;EACT;EAEA,OAAO;AACT;;;AFZO,IAAMhB,YAAA,GAAeA,CAAC3C,MAAA,EAAgBhC,IAAA,KAAiB;EAG5D,IAAI,CAACuI,aAAA,CAAavG,MAAA,CAAOoD,KAAA,EAAOpF,IAAI,GAAG;IACrC,OAAO;EACT;EAIA,IAAI,CAACsI,aAAA,CAActG,MAAA,CAAOoD,KAAA,EAAOpF,IAAI,GAAG;IACtC,OAAO;EACT;EAIA,MAAM;IAAEsF;EAAU,IAAItD,MAAA,CAAOoD,KAAA;EAC7B,MAAM;IAAEC,KAAA;IAAOoD;EAAI,IAAInD,SAAA;EAEvB,IAAI,CAACA,SAAA,CAAUoD,KAAA,IAASrD,KAAA,CAAMsD,UAAA,CAAWF,GAAG,GAAG;IAC7C,OAAO;EACT;EAGA,IAAIzD,gBAAA,CAAiBhF,IAAA,EAAMgC,MAAA,CAAOoD,KAAK,GAAG;IACxC,OAAOpD,MAAA,CACJH,KAAA,CAAM,EACN+G,KAAA,CAAM5G,MAAA,CAAOoD,KAAA,CAAME,SAAA,CAAUgC,IAAA,GAAO,CAAC,EACrCuB,IAAA,CAAK7I,IAAI,EACT8I,YAAA,CAAa,EACb5G,GAAA,CAAI;EACT;EAEA,IAAI+C,gBAAA,CAAiBjF,IAAA,EAAMgC,MAAA,CAAOoD,KAAK,GAAG;IACxC,OAAOpD,MAAA,CAAOH,KAAA,CAAM,EAAEoG,WAAA,CAAY,EAAEa,YAAA,CAAa,EAAE5G,GAAA,CAAI;EACzD;EAEA,OAAOF,MAAA,CAAOJ,QAAA,CAASmH,eAAA,CAAgB;AACzC;;;AGzCO,IAAMlE,gBAAA,GAAmBA,CAACM,UAAA,EAAoBC,KAAA,KAAgC;EAFrF,IAAA0B,EAAA;EAGE,MAAM;IAAEN;EAAQ,IAAIpB,KAAA,CAAME,SAAA;EAE1B,MAAMyB,UAAA,GAAa3B,KAAA,CAAMY,GAAA,CAAIC,OAAA,CAAQO,OAAA,CAAQX,GAAA,GAAMW,OAAA,CAAQwC,YAAA,GAAe,CAAC;EAE3E,IAAIjC,UAAA,CAAWjD,KAAA,CAAM,MAAMiD,UAAA,CAAWkC,MAAA,CAAOC,UAAA,GAAa,GAAG;IAC3D,OAAO;EACT;EAEA,MAAIpC,EAAA,GAAAC,UAAA,CAAWoC,SAAA,KAAX,gBAAArC,EAAA,CAAsB9F,IAAA,CAAKhB,IAAA,MAASmF,UAAA,EAAY;IAClD,OAAO;EACT;EAEA,OAAO;AACT;;;AXOO,IAAMiE,UAAA,GAAa/E,SAAA,CAAUtE,MAAA,CAA0B;EAC5DC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLoJ,SAAA,EAAW,CACT;QACEC,QAAA,EAAU;QACVC,YAAA,EAAc,CAAC,cAAc,aAAa;MAC5C,GACA;QACED,QAAA,EAAU;QACVC,YAAA,EAAc,CAAC,UAAU;MAC3B;IAEJ;EACF;EAEApH,qBAAA,EAAuB;IACrB,OAAO;MACLqH,MAAA,EAAQA,CAAC;QAAExH;MAAO,MAAM;QACtB,IAAIyH,OAAA,GAAU;QAEd,KAAKjJ,OAAA,CAAQ6I,SAAA,CAAUK,OAAA,CAAQ,CAAC;UAAEJ;QAAS,MAAM;UAC/C,IAAItH,MAAA,CAAOoD,KAAA,CAAMI,MAAA,CAAOmE,KAAA,CAAML,QAAQ,MAAM,QAAW;YACrD;UACF;UAEA,IAAI3E,YAAA,CAAa3C,MAAA,EAAQsH,QAAQ,GAAG;YAClCG,OAAA,GAAU;UACZ;QACF,CAAC;QAED,OAAOA,OAAA;MACT;MACA,cAAcG,CAAC;QAAE5H;MAAO,MAAM;QAC5B,IAAIyH,OAAA,GAAU;QAEd,KAAKjJ,OAAA,CAAQ6I,SAAA,CAAUK,OAAA,CAAQ,CAAC;UAAEJ;QAAS,MAAM;UAC/C,IAAItH,MAAA,CAAOoD,KAAA,CAAMI,MAAA,CAAOmE,KAAA,CAAML,QAAQ,MAAM,QAAW;YACrD;UACF;UAEA,IAAI3E,YAAA,CAAa3C,MAAA,EAAQsH,QAAQ,GAAG;YAClCG,OAAA,GAAU;UACZ;QACF,CAAC;QAED,OAAOA,OAAA;MACT;MACAI,SAAA,EAAWA,CAAC;QAAE7H;MAAO,MAAM;QACzB,IAAIyH,OAAA,GAAU;QAEd,KAAKjJ,OAAA,CAAQ6I,SAAA,CAAUK,OAAA,CAAQ,CAAC;UAAEJ,QAAA;UAAUC;QAAa,MAAM;UAC7D,IAAIvH,MAAA,CAAOoD,KAAA,CAAMI,MAAA,CAAOmE,KAAA,CAAML,QAAQ,MAAM,QAAW;YACrD;UACF;UAEA,IAAI5E,eAAA,CAAgB1C,MAAA,EAAQsH,QAAA,EAAUC,YAAY,GAAG;YACnDE,OAAA,GAAU;UACZ;QACF,CAAC;QAED,OAAOA,OAAA;MACT;MACA,iBAAiBK,CAAC;QAAE9H;MAAO,MAAM;QAC/B,IAAIyH,OAAA,GAAU;QAEd,KAAKjJ,OAAA,CAAQ6I,SAAA,CAAUK,OAAA,CAAQ,CAAC;UAAEJ,QAAA;UAAUC;QAAa,MAAM;UAC7D,IAAIvH,MAAA,CAAOoD,KAAA,CAAMI,MAAA,CAAOmE,KAAA,CAAML,QAAQ,MAAM,QAAW;YACrD;UACF;UAEA,IAAI5E,eAAA,CAAgB1C,MAAA,EAAQsH,QAAA,EAAUC,YAAY,GAAG;YACnDE,OAAA,GAAU;UACZ;QACF,CAAC;QAED,OAAOA,OAAA;MACT;IACF;EACF;AACF,CAAC;;;AYzGD,SAASpF,SAAA,IAAA0F,UAAA,QAAiB;;;ACA1B,SAASvK,eAAA,IAAAwK,gBAAA,EAAiBvK,IAAA,IAAAwK,KAAA,EAAMvK,iBAAA,IAAAwK,kBAAA,QAAyB;;;ACOzD,IAAMC,uBAAA,GAA0B;AAMhC,IAAMC,mBAAA,GAAsB;AAoBrB,SAASC,wBAAwBC,KAAA,EAA8C;EACpF,MAAMC,SAAA,GAA+B,EAAC;EACtC,IAAIC,gBAAA,GAAmB;EACvB,IAAIC,QAAA,GAAW;EAEf,OAAOD,gBAAA,GAAmBF,KAAA,CAAMtH,MAAA,EAAQ;IACtC,MAAM0H,IAAA,GAAOJ,KAAA,CAAME,gBAAgB;IACnC,MAAMG,KAAA,GAAQD,IAAA,CAAKC,KAAA,CAAMR,uBAAuB;IAEhD,IAAI,CAACQ,KAAA,EAAO;MACV;IACF;IAEA,MAAM,GAAGC,MAAA,EAAQC,MAAA,EAAQtK,OAAO,IAAIoK,KAAA;IACpC,MAAMG,WAAA,GAAcF,MAAA,CAAO5H,MAAA;IAC3B,IAAI+H,WAAA,GAAcxK,OAAA;IAClB,IAAIyK,aAAA,GAAgBR,gBAAA,GAAmB;IACvC,MAAMS,SAAA,GAAY,CAACP,IAAI;IAGvB,OAAOM,aAAA,GAAgBV,KAAA,CAAMtH,MAAA,EAAQ;MACnC,MAAMkI,QAAA,GAAWZ,KAAA,CAAMU,aAAa;MACpC,MAAMG,SAAA,GAAYD,QAAA,CAASP,KAAA,CAAMR,uBAAuB;MAGxD,IAAIgB,SAAA,EAAW;QACb;MACF;MAGA,IAAID,QAAA,CAASE,IAAA,CAAK,MAAM,IAAI;QAE1BH,SAAA,CAAUvH,IAAA,CAAKwH,QAAQ;QACvBH,WAAA,IAAe;QACfC,aAAA,IAAiB;MACnB,WAAWE,QAAA,CAASP,KAAA,CAAMP,mBAAmB,GAAG;QAE9Ca,SAAA,CAAUvH,IAAA,CAAKwH,QAAQ;QACvBH,WAAA,IAAe;AAAA,EAAKG,QAAA,CAAS1H,KAAA,CAAMsH,WAAA,GAAc,CAAC,CAAC;QACnDE,aAAA,IAAiB;MACnB,OAAO;QAEL;MACF;IACF;IAEAT,SAAA,CAAU7G,IAAA,CAAK;MACbkH,MAAA,EAAQE,WAAA;MACRD,MAAA,EAAQQ,QAAA,CAASR,MAAA,EAAQ,EAAE;MAC3BtK,OAAA,EAASwK,WAAA,CAAYK,IAAA,CAAK;MAC1BE,GAAA,EAAKL,SAAA,CAAUM,IAAA,CAAK,IAAI;IAC1B,CAAC;IAEDd,QAAA,GAAWO,aAAA;IACXR,gBAAA,GAAmBQ,aAAA;EACrB;EAEA,OAAO,CAACT,SAAA,EAAWE,QAAQ;AAC7B;AAYO,SAASe,qBACdtK,KAAA,EACAuK,UAAA,EACAC,KAAA,EACW;EA3Gb,IAAA5E,EAAA;EA4GE,MAAM6E,MAAA,GAAoB,EAAC;EAC3B,IAAIC,YAAA,GAAe;EAEnB,OAAOA,YAAA,GAAe1K,KAAA,CAAM8B,MAAA,EAAQ;IAClC,MAAM6I,IAAA,GAAO3K,KAAA,CAAM0K,YAAY;IAE/B,IAAIC,IAAA,CAAKjB,MAAA,KAAWa,UAAA,EAAY;MAE9B,MAAMK,YAAA,GAAeD,IAAA,CAAKtL,OAAA,CAAQwL,KAAA,CAAM,IAAI;MAC5C,MAAMC,QAAA,KAAWlF,EAAA,GAAAgF,YAAA,CAAa,CAAC,MAAd,gBAAAhF,EAAA,CAAiBsE,IAAA,OAAU;MAE5C,MAAMrI,MAAA,GAAS,EAAC;MAGhB,IAAIiJ,QAAA,EAAU;QACZjJ,MAAA,CAAOW,IAAA,CAAK;UACV1C,IAAA,EAAM;UACNsK,GAAA,EAAKU,QAAA;UACLjJ,MAAA,EAAQ2I,KAAA,CAAMO,YAAA,CAAaD,QAAQ;QACrC,CAAC;MACH;MAGA,MAAMvI,iBAAA,GAAoBqI,YAAA,CAAatI,KAAA,CAAM,CAAC,EAAE+H,IAAA,CAAK,IAAI,EAAEH,IAAA,CAAK;MAChE,IAAI3H,iBAAA,EAAmB;QAErB,MAAMyI,WAAA,GAAcR,KAAA,CAAMQ,WAAA,CAAYzI,iBAAiB;QACvDV,MAAA,CAAOW,IAAA,CAAK,GAAGwI,WAAW;MAC5B;MAGA,IAAIC,cAAA,GAAiBP,YAAA,GAAe;MACpC,MAAMQ,WAAA,GAAc,EAAC;MAErB,OAAOD,cAAA,GAAiBjL,KAAA,CAAM8B,MAAA,IAAU9B,KAAA,CAAMiL,cAAc,EAAEvB,MAAA,GAASa,UAAA,EAAY;QACjFW,WAAA,CAAY1I,IAAA,CAAKxC,KAAA,CAAMiL,cAAc,CAAC;QACtCA,cAAA,IAAkB;MACpB;MAGA,IAAIC,WAAA,CAAYpJ,MAAA,GAAS,GAAG;QAE1B,MAAMqJ,UAAA,GAAa3F,IAAA,CAAK4F,GAAA,CAAI,GAAGF,WAAA,CAAYG,GAAA,CAAIC,UAAA,IAAcA,UAAA,CAAW5B,MAAM,CAAC;QAI/E,MAAM6B,eAAA,GAAkBjB,oBAAA,CAAqBY,WAAA,EAAaC,UAAA,EAAYX,KAAK;QAG3E3I,MAAA,CAAOW,IAAA,CAAK;UACV1C,IAAA,EAAM;UACNC,OAAA,EAAS;UACT6G,KAAA,EAAOsE,WAAA,CAAY,CAAC,EAAEvB,MAAA;UACtB3J,KAAA,EAAOuL,eAAA;UACPnB,GAAA,EAAKc,WAAA,CAAYG,GAAA,CAAIC,UAAA,IAAcA,UAAA,CAAWlB,GAAG,EAAEC,IAAA,CAAK,IAAI;QAC9D,CAAC;MACH;MAEAI,MAAA,CAAOjI,IAAA,CAAK;QACV1C,IAAA,EAAM;QACNsK,GAAA,EAAKO,IAAA,CAAKP,GAAA;QACVvI;MACF,CAAC;MAGD6I,YAAA,GAAeO,cAAA;IACjB,OAAO;MAGLP,YAAA,IAAgB;IAClB;EACF;EAEA,OAAOD,MAAA;AACT;AAUO,SAASe,eAAexL,KAAA,EAAwBH,OAAA,EAA8C;EACnG,OAAOG,KAAA,CAAMqL,GAAA,CAAIV,IAAA,IAAQ;IACvB,IAAIA,IAAA,CAAK7K,IAAA,KAAS,aAAa;MAC7B,OAAOD,OAAA,CAAQI,aAAA,CAAc,CAAC0K,IAAI,CAAC,EAAE,CAAC;IACxC;IAGA,MAAMtL,OAAA,GAAyB,EAAC;IAEhC,IAAIsL,IAAA,CAAK9I,MAAA,IAAU8I,IAAA,CAAK9I,MAAA,CAAOC,MAAA,GAAS,GAAG;MACzC6I,IAAA,CAAK9I,MAAA,CAAO2G,OAAA,CAAQiD,SAAA,IAAa;QAE/B,IACEA,SAAA,CAAU3L,IAAA,KAAS,eACnB2L,SAAA,CAAU3L,IAAA,KAAS,UACnB2L,SAAA,CAAU3L,IAAA,KAAS,gBACnB2L,SAAA,CAAU3L,IAAA,KAAS,QACnB;UACAT,OAAA,CAAQmD,IAAA,CAAK,GAAG3C,OAAA,CAAQI,aAAA,CAAc,CAACwL,SAAS,CAAC,CAAC;QACpD,WAAWA,SAAA,CAAU3L,IAAA,KAAS,UAAU2L,SAAA,CAAU5J,MAAA,EAAQ;UAExD,MAAMM,aAAA,GAAgBtC,OAAA,CAAQI,aAAA,CAAc,CAACwL,SAAS,CAAC;UACvDpM,OAAA,CAAQmD,IAAA,CAAK;YACX1C,IAAA,EAAM;YACNT,OAAA,EAAS8C;UACX,CAAC;QACH,OAAO;UAEL,MAAMuJ,MAAA,GAAS7L,OAAA,CAAQI,aAAA,CAAc,CAACwL,SAAS,CAAC;UAChD,IAAIC,MAAA,CAAO5J,MAAA,GAAS,GAAG;YACrBzC,OAAA,CAAQmD,IAAA,CAAK,GAAGkJ,MAAM;UACxB;QACF;MACF,CAAC;IACH;IAEA,OAAO;MACL5L,IAAA,EAAM;MACNT;IACF;EACF,CAAC;AACH;;;ADrOA,IAAMsM,aAAA,GAAe;AACrB,IAAMC,cAAA,GAAgB;AA+Cf,IAAMC,qBAAA,GAAwB;AAQ9B,IAAMC,WAAA,GAAc/C,KAAA,CAAKlK,MAAA,CAA2B;EACzDC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLC,YAAA,EAAc;MACdC,cAAA,EAAgB,CAAC;MACjBC,SAAA,EAAW;MACXC,cAAA,EAAgB;IAClB;EACF;EAEAC,KAAA,EAAO;EAEPC,QAAA,EAAU;IACR,OAAO,GAAG,KAAKC,OAAA,CAAQN,YAAY;EACrC;EAEA+M,cAAA,EAAgB;IACd,OAAO;MACLnF,KAAA,EAAO;QACLoF,OAAA,EAAS;QACTzM,SAAA,EAAW0M,OAAA,IAAW;UACpB,OAAOA,OAAA,CAAQC,YAAA,CAAa,OAAO,IAAI/B,QAAA,CAAS8B,OAAA,CAAQE,YAAA,CAAa,OAAO,KAAK,IAAI,EAAE,IAAI;QAC7F;MACF;MACArM,IAAA,EAAM;QACJkM,OAAA,EAAS;QACTzM,SAAA,EAAW0M,OAAA,IAAWA,OAAA,CAAQE,YAAA,CAAa,MAAM;MACnD;IACF;EACF;EAEA5M,UAAA,EAAY;IACV,OAAO,CACL;MACEC,GAAA,EAAK;IACP,EACF;EACF;EAEAC,WAAW;IAAER;EAAe,GAAG;IAC7B,MAAM;MAAE2H,KAAA;MAAO,GAAGwF;IAAuB,IAAInN,cAAA;IAE7C,OAAO2H,KAAA,KAAU,IACb,CAAC,MAAMkC,gBAAA,CAAgB,KAAKxJ,OAAA,CAAQL,cAAA,EAAgBmN,sBAAsB,GAAG,CAAC,IAC9E,CAAC,MAAMtD,gBAAA,CAAgB,KAAKxJ,OAAA,CAAQL,cAAA,EAAgBA,cAAc,GAAG,CAAC;EAC5E;EAEAS,iBAAA,EAAmB;EAEnBC,aAAA,EAAeA,CAACC,KAAA,EAAOC,OAAA,KAAY;IACjC,IAAID,KAAA,CAAME,IAAA,KAAS,UAAU,CAACF,KAAA,CAAMG,OAAA,EAAS;MAC3C,OAAO,EAAC;IACV;IAEA,MAAMsM,UAAA,GAAazM,KAAA,CAAMgH,KAAA,IAAS;IAClC,MAAMvH,OAAA,GAAUO,KAAA,CAAMI,KAAA,GAAQwL,cAAA,CAAe5L,KAAA,CAAMI,KAAA,EAAOH,OAAO,IAAI,EAAC;IAEtE,IAAIwM,UAAA,KAAe,GAAG;MACpB,OAAO;QACLvM,IAAA,EAAM;QACNwM,KAAA,EAAO;UAAE1F,KAAA,EAAOyF;QAAW;QAC3BhN;MACF;IACF;IAEA,OAAO;MACLS,IAAA,EAAM;MACNT;IACF;EACF;EAEAa,cAAA,EAAgBA,CAACC,IAAA,EAAMC,CAAA,KAAM;IAC3B,IAAI,CAACD,IAAA,CAAKd,OAAA,EAAS;MACjB,OAAO;IACT;IAEA,OAAOe,CAAA,CAAEC,cAAA,CAAeF,IAAA,CAAKd,OAAA,EAAS,IAAI;EAC5C;EAEAkN,iBAAA,EAAmB;IACjBzN,IAAA,EAAM;IACN0N,KAAA,EAAO;IACP5F,KAAA,EAAQ6F,GAAA,IAAgB;MACtB,MAAMhD,KAAA,GAAQgD,GAAA,CAAIhD,KAAA,CAAM,kBAAkB;MAC1C,MAAM7G,KAAA,GAAQ6G,KAAA,oBAAAA,KAAA,CAAO7G,KAAA;MACrB,OAAOA,KAAA,KAAU,SAAYA,KAAA,GAAQ;IACvC;IACA8J,QAAA,EAAUA,CAACD,GAAA,EAAaE,OAAA,EAASnC,KAAA,KAAU;MArJ/C,IAAA5E,EAAA;MAsJM,MAAMwD,KAAA,GAAQqD,GAAA,CAAI5B,KAAA,CAAM,IAAI;MAC5B,MAAM,CAACxB,SAAA,EAAWE,QAAQ,IAAIJ,uBAAA,CAAwBC,KAAK;MAE3D,IAAIC,SAAA,CAAUvH,MAAA,KAAW,GAAG;QAC1B,OAAO;MACT;MAEA,MAAM9B,KAAA,GAAQsK,oBAAA,CAAqBjB,SAAA,EAAW,GAAGmB,KAAK;MAEtD,IAAIxK,KAAA,CAAM8B,MAAA,KAAW,GAAG;QACtB,OAAO;MACT;MAEA,MAAMuK,UAAA,KAAazG,EAAA,GAAAyD,SAAA,CAAU,CAAC,MAAX,gBAAAzD,EAAA,CAAc+D,MAAA,KAAU;MAE3C,OAAO;QACL7J,IAAA,EAAM;QACNC,OAAA,EAAS;QACT6G,KAAA,EAAOyF,UAAA;QACPrM,KAAA;QACAoK,GAAA,EAAKhB,KAAA,CAAM9G,KAAA,CAAM,GAAGiH,QAAQ,EAAEc,IAAA,CAAK,IAAI;MACzC;IACF;EACF;EAEA/J,eAAA,EAAiB;IACfC,cAAA,EAAgB;EAClB;EAEAC,YAAA,EAAc;IACZ,OAAO;MACLoM,iBAAA,EACEA,CAAA,KACA,CAAC;QAAElM,QAAA;QAAUC;MAAM,MAAM;QACvB,IAAI,KAAKrB,OAAA,CAAQH,cAAA,EAAgB;UAC/B,OAAOwB,KAAA,CAAM,EACVC,UAAA,CAAW,KAAK9B,IAAA,EAAM,KAAKQ,OAAA,CAAQN,YAAA,EAAc,KAAKM,OAAA,CAAQJ,SAAS,EACvE2B,gBAAA,CAAiB8K,aAAA,EAAc,KAAK7K,MAAA,CAAOC,aAAA,CAAc6K,cAAa,CAAC,EACvE5K,GAAA,CAAI;QACT;QACA,OAAON,QAAA,CAASE,UAAA,CAAW,KAAK9B,IAAA,EAAM,KAAKQ,OAAA,CAAQN,YAAA,EAAc,KAAKM,OAAA,CAAQJ,SAAS;MACzF;IACJ;EACF;EAEA+B,qBAAA,EAAuB;IACrB,OAAO;MACL,eAAe4L,CAAA,KAAM,KAAK/L,MAAA,CAAOJ,QAAA,CAASkM,iBAAA,CAAkB;IAC9D;EACF;EAEAzL,cAAA,EAAgB;IACd,IAAIC,SAAA,GAAY4H,kBAAA,CAAkB;MAChC3H,IAAA,EAAMwK,qBAAA;MACN/L,IAAA,EAAM,KAAKA,IAAA;MACXiB,aAAA,EAAe0I,KAAA,KAAU;QAAE7C,KAAA,EAAO,CAAC6C,KAAA,CAAM,CAAC;MAAE;MAC5CqD,aAAA,EAAeA,CAACrD,KAAA,EAAOtJ,IAAA,KAASA,IAAA,CAAK6H,UAAA,GAAa7H,IAAA,CAAKmM,KAAA,CAAM1F,KAAA,KAAU,CAAC6C,KAAA,CAAM,CAAC;IACjF,CAAC;IAED,IAAI,KAAKnK,OAAA,CAAQJ,SAAA,IAAa,KAAKI,OAAA,CAAQH,cAAA,EAAgB;MACzDiC,SAAA,GAAY4H,kBAAA,CAAkB;QAC5B3H,IAAA,EAAMwK,qBAAA;QACN/L,IAAA,EAAM,KAAKA,IAAA;QACXZ,SAAA,EAAW,KAAKI,OAAA,CAAQJ,SAAA;QACxBC,cAAA,EAAgB,KAAKG,OAAA,CAAQH,cAAA;QAC7B4B,aAAA,EAAe0I,KAAA,KAAU;UAAE7C,KAAA,EAAO,CAAC6C,KAAA,CAAM,CAAC;UAAG,GAAG,KAAK3I,MAAA,CAAOC,aAAA,CAAc6K,cAAa;QAAE;QACzFkB,aAAA,EAAeA,CAACrD,KAAA,EAAOtJ,IAAA,KAASA,IAAA,CAAK6H,UAAA,GAAa7H,IAAA,CAAKmM,KAAA,CAAM1F,KAAA,KAAU,CAAC6C,KAAA,CAAM,CAAC;QAC/E3I,MAAA,EAAQ,KAAKA;MACf,CAAC;IACH;IACA,OAAO,CAACM,SAAS;EACnB;AACF,CAAC;;;AE7ND,SAAS9C,eAAA,IAAAyO,gBAAA,EAAiBxO,IAAA,IAAAyO,KAAA,EAAMxL,2BAAA,IAAAyL,4BAAA,EAA6BzO,iBAAA,IAAA0O,kBAAA,QAAyB;AAkD/E,IAAMC,UAAA,GAAa;AAMnB,IAAMC,QAAA,GAAWJ,KAAA,CAAKnO,MAAA,CAAwB;EACnDC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLsO,MAAA,EAAQ;MACRpO,cAAA,EAAgB,CAAC;MACjBqO,gBAAA,EAAkB;MAClBC,IAAA,EAAM;IACR;EACF;EAEAlO,QAAA,EAAU;IACR,OAAO,KAAKC,OAAA,CAAQ+N,MAAA,GAAS,qBAAqB;EACpD;EAEAzL,QAAA,EAAU;EAEVmK,cAAA,EAAgB;IACd,OAAO;MACLyB,OAAA,EAAS;QACPxB,OAAA,EAAS;QACTyB,WAAA,EAAa;QACblO,SAAA,EAAW0M,OAAA,IAAW;UACpB,MAAMyB,WAAA,GAAczB,OAAA,CAAQE,YAAA,CAAa,cAAc;UAEvD,OAAOuB,WAAA,KAAgB,MAAMA,WAAA,KAAgB;QAC/C;QACAjO,UAAA,EAAYkO,UAAA,KAAe;UACzB,gBAAgBA,UAAA,CAAWH;QAC7B;MACF;IACF;EACF;EAEAjO,UAAA,EAAY;IACV,OAAO,CACL;MACEC,GAAA,EAAK,iBAAiB,KAAKV,IAAI;MAC/B8O,QAAA,EAAU;IACZ,EACF;EACF;EAEAnO,WAAW;IAAEU,IAAA;IAAMlB;EAAe,GAAG;IACnC,OAAO,CACL,MACA8N,gBAAA,CAAgB,KAAKzN,OAAA,CAAQL,cAAA,EAAgBA,cAAA,EAAgB;MAC3D,aAAa,KAAKH;IACpB,CAAC,GACD,CACE,SACA,CACE,SACA;MACEgB,IAAA,EAAM;MACN0N,OAAA,EAASrN,IAAA,CAAKmM,KAAA,CAAMkB,OAAA,GAAU,YAAY;IAC5C,EACF,EACA,CAAC,MAAM,EACT,EACA,CAAC,OAAO,CAAC,EACX;EACF;EAEA7N,aAAA,EAAeA,CAACC,KAAA,EAAOQ,CAAA,KAAM;IAE3B,MAAMf,OAAA,GAAU,EAAC;IAGjB,IAAIO,KAAA,CAAMiC,MAAA,IAAUjC,KAAA,CAAMiC,MAAA,CAAOC,MAAA,GAAS,GAAG;MAE3CzC,OAAA,CAAQmD,IAAA,CAAKpC,CAAA,CAAEyN,UAAA,CAAW,aAAa,CAAC,GAAGzN,CAAA,CAAEgC,WAAA,CAAYxC,KAAA,CAAMiC,MAAM,CAAC,CAAC;IACzE,WAAWjC,KAAA,CAAMkO,IAAA,EAAM;MAErBzO,OAAA,CAAQmD,IAAA,CAAKpC,CAAA,CAAEyN,UAAA,CAAW,aAAa,CAAC,GAAG,CAACzN,CAAA,CAAEyN,UAAA,CAAW,QAAQ;QAAEC,IAAA,EAAMlO,KAAA,CAAMkO;MAAK,CAAC,CAAC,CAAC,CAAC;IAC1F,OAAO;MAELzO,OAAA,CAAQmD,IAAA,CAAKpC,CAAA,CAAEyN,UAAA,CAAW,aAAa,CAAC,GAAG,EAAE,CAAC;IAChD;IAGA,IAAIjO,KAAA,CAAMmO,YAAA,IAAgBnO,KAAA,CAAMmO,YAAA,CAAajM,MAAA,GAAS,GAAG;MACvD,MAAMkM,aAAA,GAAgB5N,CAAA,CAAEH,aAAA,CAAcL,KAAA,CAAMmO,YAAY;MACxD1O,OAAA,CAAQmD,IAAA,CAAK,GAAGwL,aAAa;IAC/B;IAEA,OAAO5N,CAAA,CAAEyN,UAAA,CAAW,YAAY;MAAEL,OAAA,EAAS5N,KAAA,CAAM4N,OAAA,IAAW;IAAM,GAAGnO,OAAO;EAC9E;EAEAa,cAAA,EAAgBA,CAACC,IAAA,EAAMC,CAAA,KAAM;IAnJ/B,IAAAwF,EAAA;IAoJI,MAAMqI,WAAA,KAAcrI,EAAA,GAAAzF,IAAA,CAAKmM,KAAA,KAAL,gBAAA1G,EAAA,CAAY4H,OAAA,IAAU,MAAM;IAChD,MAAMU,MAAA,GAAS,MAAMD,WAAW;IAEhC,OAAOhB,4BAAA,CAA4B9M,IAAA,EAAMC,CAAA,EAAG8N,MAAM;EACpD;EAEAjN,qBAAA,EAAuB;IACrB,MAAMkN,SAAA,GAEF;MACFtL,KAAA,EAAOA,CAAA,KAAM,KAAK/B,MAAA,CAAOJ,QAAA,CAASoC,aAAA,CAAc,KAAKhE,IAAI;MACzD,aAAamE,CAAA,KAAM,KAAKnC,MAAA,CAAOJ,QAAA,CAASwC,YAAA,CAAa,KAAKpE,IAAI;IAChE;IAEA,IAAI,CAAC,KAAKQ,OAAA,CAAQ+N,MAAA,EAAQ;MACxB,OAAOc,SAAA;IACT;IAEA,OAAO;MACL,GAAGA,SAAA;MACHpL,GAAA,EAAKA,CAAA,KAAM,KAAKjC,MAAA,CAAOJ,QAAA,CAASsC,YAAA,CAAa,KAAKlE,IAAI;IACxD;EACF;EAEAsP,YAAA,EAAc;IACZ,OAAO,CAAC;MAAEjO,IAAA;MAAMlB,cAAA;MAAgBoP,MAAA;MAAQvN;IAAO,MAAM;MACnD,MAAMwN,QAAA,GAAWC,QAAA,CAASC,aAAA,CAAc,IAAI;MAC5C,MAAMC,eAAA,GAAkBF,QAAA,CAASC,aAAA,CAAc,OAAO;MACtD,MAAME,cAAA,GAAiBH,QAAA,CAASC,aAAA,CAAc,MAAM;MACpD,MAAMG,QAAA,GAAWJ,QAAA,CAASC,aAAA,CAAc,OAAO;MAC/C,MAAMnP,OAAA,GAAUkP,QAAA,CAASC,aAAA,CAAc,KAAK;MAE5C,MAAMI,UAAA,GAAcrK,WAAA,IAAiC;QApL3D,IAAAqB,EAAA,EAAAiJ,EAAA;QAqLQF,QAAA,CAASG,SAAA,KACPD,EAAA,IAAAjJ,EAAA,QAAKtG,OAAA,CAAQiO,IAAA,KAAb,gBAAA3H,EAAA,CAAmBmJ,aAAA,KAAnB,gBAAAF,EAAA,CAAAG,IAAA,CAAApJ,EAAA,EAAmCrB,WAAA,EAAaoK,QAAA,CAASnB,OAAA,MACzD,0BAA0BjJ,WAAA,CAAY0K,WAAA,IAAe,iBAAiB;MAC1E;MAEAL,UAAA,CAAWzO,IAAI;MAEfsO,eAAA,CAAgBS,eAAA,GAAkB;MAClCP,QAAA,CAAS7O,IAAA,GAAO;MAChB6O,QAAA,CAASQ,gBAAA,CAAiB,aAAaC,KAAA,IAASA,KAAA,CAAMC,cAAA,CAAe,CAAC;MACtEV,QAAA,CAASQ,gBAAA,CAAiB,UAAUC,KAAA,IAAS;QAG3C,IAAI,CAACtO,MAAA,CAAOwO,UAAA,IAAc,CAAC,KAAKhQ,OAAA,CAAQiQ,iBAAA,EAAmB;UACzDZ,QAAA,CAASnB,OAAA,GAAU,CAACmB,QAAA,CAASnB,OAAA;UAE7B;QACF;QAEA,MAAM;UAAEA;QAAQ,IAAI4B,KAAA,CAAMI,MAAA;QAE1B,IAAI1O,MAAA,CAAOwO,UAAA,IAAc,OAAOjB,MAAA,KAAW,YAAY;UACrDvN,MAAA,CACGH,KAAA,CAAM,EACN+G,KAAA,CAAM,QAAW;YAAE+H,cAAA,EAAgB;UAAM,CAAC,EAC1CC,OAAA,CAAQ,CAAC;YAAEC;UAAG,MAAM;YACnB,MAAMC,QAAA,GAAWvB,MAAA,CAAO;YAExB,IAAI,OAAOuB,QAAA,KAAa,UAAU;cAChC,OAAO;YACT;YACA,MAAMrL,WAAA,GAAcoL,EAAA,CAAG7K,GAAA,CAAI+K,MAAA,CAAOD,QAAQ;YAE1CD,EAAA,CAAGG,aAAA,CAAcF,QAAA,EAAU,QAAW;cACpC,IAAGrL,WAAA,oBAAAA,WAAA,CAAa+H,KAAA;cAChBkB;YACF,CAAC;YAED,OAAO;UACT,CAAC,EACAxM,GAAA,CAAI;QACT;QACA,IAAI,CAACF,MAAA,CAAOwO,UAAA,IAAc,KAAKhQ,OAAA,CAAQiQ,iBAAA,EAAmB;UAExD,IAAI,CAAC,KAAKjQ,OAAA,CAAQiQ,iBAAA,CAAkBpP,IAAA,EAAMqN,OAAO,GAAG;YAClDmB,QAAA,CAASnB,OAAA,GAAU,CAACmB,QAAA,CAASnB,OAAA;UAC/B;QACF;MACF,CAAC;MAEDuC,MAAA,CAAOC,OAAA,CAAQ,KAAK1Q,OAAA,CAAQL,cAAc,EAAEuJ,OAAA,CAAQ,CAAC,CAACyH,GAAA,EAAKC,KAAK,MAAM;QACpE5B,QAAA,CAAS6B,YAAA,CAAaF,GAAA,EAAKC,KAAK;MAClC,CAAC;MAED5B,QAAA,CAAS8B,OAAA,CAAQ5C,OAAA,GAAUrN,IAAA,CAAKmM,KAAA,CAAMkB,OAAA;MACtCmB,QAAA,CAASnB,OAAA,GAAUrN,IAAA,CAAKmM,KAAA,CAAMkB,OAAA;MAE9BiB,eAAA,CAAgB4B,MAAA,CAAO1B,QAAA,EAAUD,cAAc;MAC/CJ,QAAA,CAAS+B,MAAA,CAAO5B,eAAA,EAAiBpP,OAAO;MAExC0Q,MAAA,CAAOC,OAAA,CAAQ/Q,cAAc,EAAEuJ,OAAA,CAAQ,CAAC,CAACyH,GAAA,EAAKC,KAAK,MAAM;QACvD5B,QAAA,CAAS6B,YAAA,CAAaF,GAAA,EAAKC,KAAK;MAClC,CAAC;MAED,OAAO;QACLI,GAAA,EAAKhC,QAAA;QACLiC,UAAA,EAAYlR,OAAA;QACZmR,MAAA,EAAQC,WAAA,IAAe;UACrB,IAAIA,WAAA,CAAY3Q,IAAA,KAAS,KAAKA,IAAA,EAAM;YAClC,OAAO;UACT;UAEAwO,QAAA,CAAS8B,OAAA,CAAQ5C,OAAA,GAAUiD,WAAA,CAAYnE,KAAA,CAAMkB,OAAA;UAC7CmB,QAAA,CAASnB,OAAA,GAAUiD,WAAA,CAAYnE,KAAA,CAAMkB,OAAA;UACrCoB,UAAA,CAAW6B,WAAW;UAEtB,OAAO;QACT;MACF;IACF;EACF;EAEAtP,cAAA,EAAgB;IACd,OAAO,CACL+L,kBAAA,CAAkB;MAChB7L,IAAA,EAAM8L,UAAA;MACNrN,IAAA,EAAM,KAAKA,IAAA;MACXiB,aAAA,EAAe0I,KAAA,KAAU;QACvB+D,OAAA,EAAS/D,KAAA,CAAMA,KAAA,CAAM3H,MAAA,GAAS,CAAC,MAAM;MACvC;IACF,CAAC,EACH;EACF;AACF,CAAC;;;AClRD,SAASxD,eAAA,IAAAoS,gBAAA,EAAiBnS,IAAA,IAAAoS,KAAA,EAAMC,mBAAA,QAA2B;AAkCpD,IAAMC,QAAA,GAAWF,KAAA,CAAK9R,MAAA,CAAwB;EACnDC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLC,YAAA,EAAc;MACdC,cAAA,EAAgB,CAAC;IACnB;EACF;EAEAG,KAAA,EAAO;EAEPC,QAAA,EAAU;IACR,OAAO,GAAG,KAAKC,OAAA,CAAQN,YAAY;EACrC;EAEAO,UAAA,EAAY;IACV,OAAO,CACL;MACEC,GAAA,EAAK,iBAAiB,KAAKV,IAAI;MAC/B8O,QAAA,EAAU;IACZ,EACF;EACF;EAEAnO,WAAW;IAAER;EAAe,GAAG;IAC7B,OAAO,CAAC,MAAMyR,gBAAA,CAAgB,KAAKpR,OAAA,CAAQL,cAAA,EAAgBA,cAAA,EAAgB;MAAE,aAAa,KAAKH;IAAK,CAAC,GAAG,CAAC;EAC3G;EAEAa,aAAA,EAAeA,CAACC,KAAA,EAAOQ,CAAA,KAAM;IAC3B,OAAOA,CAAA,CAAEyN,UAAA,CAAW,YAAY,CAAC,GAAGzN,CAAA,CAAEH,aAAA,CAAcL,KAAA,CAAMI,KAAA,IAAS,EAAE,CAAC;EACxE;EAEAE,cAAA,EAAgBA,CAACC,IAAA,EAAMC,CAAA,KAAM;IAC3B,IAAI,CAACD,IAAA,CAAKd,OAAA,EAAS;MACjB,OAAO;IACT;IAEA,OAAOe,CAAA,CAAEC,cAAA,CAAeF,IAAA,CAAKd,OAAA,EAAS,IAAI;EAC5C;EAEAkN,iBAAA,EAAmB;IACjBzN,IAAA,EAAM;IACN0N,KAAA,EAAO;IACP5F,MAAM6F,GAAA,EAAK;MA9Ef,IAAA7G,EAAA;MAgFM,MAAMhD,KAAA,IAAQgD,EAAA,GAAA6G,GAAA,CAAIhD,KAAA,CAAM,4BAA4B,MAAtC,gBAAA7D,EAAA,CAAyChD,KAAA;MACvD,OAAOA,KAAA,KAAU,SAAYA,KAAA,GAAQ;IACvC;IACA8J,SAASD,GAAA,EAAK5K,MAAA,EAAQ2I,KAAA,EAAO;MAE3B,MAAMsG,oBAAA,GAAwBzR,OAAA,IAAuC;QACnE,MAAM0R,YAAA,GAAeH,mBAAA,CACnBvR,OAAA,EACA;UACE2R,WAAA,EAAa;UACbC,eAAA,EAAiBxH,KAAA,KAAU;YACzBG,WAAA,EAAaH,KAAA,CAAM,CAAC,EAAE3H,MAAA;YACtBoP,WAAA,EAAazH,KAAA,CAAM,CAAC;YACpB+D,OAAA,EAAS/D,KAAA,CAAM,CAAC,EAAE0H,WAAA,CAAY,MAAM;UACtC;UACAC,WAAA,EAAaA,CAACC,IAAA,EAAMtD,YAAA,MAAkB;YACpCjO,IAAA,EAAM;YACNsK,GAAA,EAAK;YACL8G,WAAA,EAAaG,IAAA,CAAKH,WAAA;YAClBtH,WAAA,EAAayH,IAAA,CAAKzH,WAAA;YAClB4D,OAAA,EAAS6D,IAAA,CAAK7D,OAAA;YACdM,IAAA,EAAMuD,IAAA,CAAKH,WAAA;YACXrP,MAAA,EAAQ2I,KAAA,CAAMO,YAAA,CAAasG,IAAA,CAAKH,WAAW;YAC3CnD;UACF;UAAA;UAEAuD,kBAAA,EAAoBR;QACtB,GACAtG,KACF;QAEA,IAAIuG,YAAA,EAAc;UAEhB,OAAO,CACL;YACEjR,IAAA,EAAM;YACNsK,GAAA,EAAK2G,YAAA,CAAa3G,GAAA;YAClBpK,KAAA,EAAO+Q,YAAA,CAAa/Q;UACtB,EACF;QACF;QAGA,OAAOwK,KAAA,CAAMQ,WAAA,CAAY3L,OAAO;MAClC;MAEA,MAAMoL,MAAA,GAASmG,mBAAA,CACbnE,GAAA,EACA;QACEuE,WAAA,EAAa;QACbC,eAAA,EAAiBxH,KAAA,KAAU;UACzBG,WAAA,EAAaH,KAAA,CAAM,CAAC,EAAE3H,MAAA;UACtBoP,WAAA,EAAazH,KAAA,CAAM,CAAC;UACpB+D,OAAA,EAAS/D,KAAA,CAAM,CAAC,EAAE0H,WAAA,CAAY,MAAM;QACtC;QACAC,WAAA,EAAaA,CAACC,IAAA,EAAMtD,YAAA,MAAkB;UACpCjO,IAAA,EAAM;UACNsK,GAAA,EAAK;UACL8G,WAAA,EAAaG,IAAA,CAAKH,WAAA;UAClBtH,WAAA,EAAayH,IAAA,CAAKzH,WAAA;UAClB4D,OAAA,EAAS6D,IAAA,CAAK7D,OAAA;UACdM,IAAA,EAAMuD,IAAA,CAAKH,WAAA;UACXrP,MAAA,EAAQ2I,KAAA,CAAMO,YAAA,CAAasG,IAAA,CAAKH,WAAW;UAC3CnD;QACF;QAAA;QAEAuD,kBAAA,EAAoBR;MACtB,GACAtG,KACF;MAEA,IAAI,CAACC,MAAA,EAAQ;QACX,OAAO;MACT;MAEA,OAAO;QACL3K,IAAA,EAAM;QACNsK,GAAA,EAAKK,MAAA,CAAOL,GAAA;QACZpK,KAAA,EAAOyK,MAAA,CAAOzK;MAChB;IACF;EACF;EAEAM,eAAA,EAAiB;IACfC,cAAA,EAAgB;EAClB;EAEAC,YAAA,EAAc;IACZ,OAAO;MACL+Q,cAAA,EACEA,CAAA,KACA,CAAC;QAAE7Q;MAAS,MAAM;QAChB,OAAOA,QAAA,CAASE,UAAA,CAAW,KAAK9B,IAAA,EAAM,KAAKQ,OAAA,CAAQN,YAAY;MACjE;IACJ;EACF;EAEAiC,qBAAA,EAAuB;IACrB,OAAO;MACL,eAAeuQ,CAAA,KAAM,KAAK1Q,MAAA,CAAOJ,QAAA,CAAS6Q,cAAA,CAAe;IAC3D;EACF;AACF,CAAC;;;AJtIM,IAAME,OAAA,GAAU5I,UAAA,CAAUhK,MAAA,CAAuB;EACtDC,IAAA,EAAM;EAEN4S,cAAA,EAAgB;IACd,MAAMC,UAAA,GAAa,EAAC;IAEpB,IAAI,KAAKrS,OAAA,CAAQsS,UAAA,KAAe,OAAO;MACrCD,UAAA,CAAWnP,IAAA,CAAK5D,UAAA,CAAWiT,SAAA,CAAU,KAAKvS,OAAA,CAAQsS,UAAU,CAAC;IAC/D;IAEA,IAAI,KAAKtS,OAAA,CAAQgP,QAAA,KAAa,OAAO;MACnCqD,UAAA,CAAWnP,IAAA,CAAKf,QAAA,CAASoQ,SAAA,CAAU,KAAKvS,OAAA,CAAQgP,QAAQ,CAAC;IAC3D;IAEA,IAAI,KAAKhP,OAAA,CAAQwS,UAAA,KAAe,OAAO;MACrCH,UAAA,CAAWnP,IAAA,CAAK0F,UAAA,CAAW2J,SAAA,CAAU,KAAKvS,OAAA,CAAQwS,UAAU,CAAC;IAC/D;IAEA,IAAI,KAAKxS,OAAA,CAAQyS,WAAA,KAAgB,OAAO;MACtCJ,UAAA,CAAWnP,IAAA,CAAKsJ,WAAA,CAAY+F,SAAA,CAAU,KAAKvS,OAAA,CAAQyS,WAAW,CAAC;IACjE;IAEA,IAAI,KAAKzS,OAAA,CAAQ0S,QAAA,KAAa,OAAO;MACnCL,UAAA,CAAWnP,IAAA,CAAK4K,QAAA,CAASyE,SAAA,CAAU,KAAKvS,OAAA,CAAQ0S,QAAQ,CAAC;IAC3D;IAEA,IAAI,KAAK1S,OAAA,CAAQ2S,QAAA,KAAa,OAAO;MACnCN,UAAA,CAAWnP,IAAA,CAAKqO,QAAA,CAASgB,SAAA,CAAU,KAAKvS,OAAA,CAAQ2S,QAAQ,CAAC;IAC3D;IAEA,OAAON,UAAA;EACT;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}