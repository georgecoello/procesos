{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// src/blockquote.tsx\nimport { mergeAttributes, Node, wrappingInputRule } from \"@tiptap/core\";\nimport { jsx } from \"@tiptap/core/jsx-runtime\";\nvar inputRegex = /^\\s*>\\s$/;\nvar Blockquote = Node.create({\n  name: \"blockquote\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  content: \"block+\",\n  group: \"block\",\n  defining: true,\n  parseHTML() {\n    return [{\n      tag: \"blockquote\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return /* @__PURE__ */jsx(\"blockquote\", {\n      ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      children: /* @__PURE__ */jsx(\"slot\", {})\n    });\n  },\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"blockquote\", void 0, helpers.parseChildren(token.tokens || []));\n  },\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return \"\";\n    }\n    const prefix = \">\";\n    const result = [];\n    node.content.forEach(child => {\n      const childContent = h.renderChildren([child]);\n      const lines = childContent.split(\"\\n\");\n      const linesWithPrefix = lines.map(line => {\n        if (line.trim() === \"\") {\n          return prefix;\n        }\n        return `${prefix} ${line}`;\n      });\n      result.push(linesWithPrefix.join(\"\\n\"));\n    });\n    return result.join(`\n${prefix}\n`);\n  },\n  addCommands() {\n    return {\n      setBlockquote: () => ({\n        commands\n      }) => {\n        return commands.wrapIn(this.name);\n      },\n      toggleBlockquote: () => ({\n        commands\n      }) => {\n        return commands.toggleWrap(this.name);\n      },\n      unsetBlockquote: () => ({\n        commands\n      }) => {\n        return commands.lift(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-b\": () => this.editor.commands.toggleBlockquote()\n    };\n  },\n  addInputRules() {\n    return [wrappingInputRule({\n      find: inputRegex,\n      type: this.type\n    })];\n  }\n});\n\n// src/index.ts\nvar index_default = Blockquote;\nexport { Blockquote, index_default as default, inputRegex };","map":{"version":3,"names":["mergeAttributes","Node","wrappingInputRule","jsx","inputRegex","Blockquote","create","name","addOptions","HTMLAttributes","content","group","defining","parseHTML","tag","renderHTML","options","children","parseMarkdown","token","helpers","createNode","parseChildren","tokens","renderMarkdown","node","h","prefix","result","forEach","child","childContent","renderChildren","lines","split","linesWithPrefix","map","line","trim","push","join","addCommands","setBlockquote","commands","wrapIn","toggleBlockquote","toggleWrap","unsetBlockquote","lift","addKeyboardShortcuts","Mod-Shift-b","editor","addInputRules","find","type","index_default"],"sources":["../src/blockquote.tsx","../src/index.ts"],"sourcesContent":["/** @jsxImportSource @tiptap/core */\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  /**\n   * HTML attributes to add to the blockquote element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nexport const inputRegex = /^\\s*>\\s$/\n\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nexport const Blockquote = Node.create<BlockquoteOptions>({\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [{ tag: 'blockquote' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <blockquote {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </blockquote>\n    )\n  },\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('blockquote', undefined, helpers.parseChildren(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    // Use a single '>' prefix regardless of nesting level\n    // Nested blockquotes will add their own '>' prefix recursively\n    const prefix = '>'\n    const result: string[] = []\n\n    node.content.forEach(child => {\n      // Render each child node as an array so it gets processed properly\n      const childContent = h.renderChildren([child])\n      const lines = childContent.split('\\n')\n\n      const linesWithPrefix = lines.map(line => {\n        // Don't add prefix to empty lines\n        if (line.trim() === '') {\n          return prefix\n        }\n\n        // Nested blockquotes will already have their own prefixes\n        // We just need to add our own prefix at the start\n        return `${prefix} ${line}`\n      })\n\n      result.push(linesWithPrefix.join('\\n'))\n    })\n\n    // Add separator lines between children\n    return result.join(`\\n${prefix}\\n`)\n  },\n\n  addCommands() {\n    return {\n      setBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.wrapIn(this.name)\n        },\n      toggleBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.toggleWrap(this.name)\n        },\n      unsetBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.lift(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Blockquote } from './blockquote.jsx'\n\nexport * from './blockquote.jsx'\n\nexport default Blockquote\n"],"mappings":";;;;;AACA,SAASA,eAAA,EAAiBC,IAAA,EAAMC,iBAAA,QAAyB;AA6DjD,SAAAC,GAAA;AA5BD,IAAMC,UAAA,GAAa;AAMnB,IAAMC,UAAA,GAAaJ,IAAA,CAAKK,MAAA,CAA0B;EACvDC,IAAA,EAAM;EAENC,WAAA,EAAa;IACX,OAAO;MACLC,cAAA,EAAgB,CAAC;IACnB;EACF;EAEAC,OAAA,EAAS;EAETC,KAAA,EAAO;EAEPC,QAAA,EAAU;EAEVC,UAAA,EAAY;IACV,OAAO,CAAC;MAAEC,GAAA,EAAK;IAAa,CAAC;EAC/B;EAEAC,WAAW;IAAEN;EAAe,GAAG;IAC7B,OACE,eAAAN,GAAA,CAAC;MAAY,GAAGH,eAAA,CAAgB,KAAKgB,OAAA,CAAQP,cAAA,EAAgBA,cAAc;MACzEQ,QAAA,iBAAAd,GAAA,CAAC,UAAK;IAAA,CACR;EAEJ;EAEAe,aAAA,EAAeA,CAACC,KAAA,EAAOC,OAAA,KAAY;IACjC,OAAOA,OAAA,CAAQC,UAAA,CAAW,cAAc,QAAWD,OAAA,CAAQE,aAAA,CAAcH,KAAA,CAAMI,MAAA,IAAU,EAAE,CAAC;EAC9F;EAEAC,cAAA,EAAgBA,CAACC,IAAA,EAAMC,CAAA,KAAM;IAC3B,IAAI,CAACD,IAAA,CAAKf,OAAA,EAAS;MACjB,OAAO;IACT;IAIA,MAAMiB,MAAA,GAAS;IACf,MAAMC,MAAA,GAAmB,EAAC;IAE1BH,IAAA,CAAKf,OAAA,CAAQmB,OAAA,CAAQC,KAAA,IAAS;MAE5B,MAAMC,YAAA,GAAeL,CAAA,CAAEM,cAAA,CAAe,CAACF,KAAK,CAAC;MAC7C,MAAMG,KAAA,GAAQF,YAAA,CAAaG,KAAA,CAAM,IAAI;MAErC,MAAMC,eAAA,GAAkBF,KAAA,CAAMG,GAAA,CAAIC,IAAA,IAAQ;QAExC,IAAIA,IAAA,CAAKC,IAAA,CAAK,MAAM,IAAI;UACtB,OAAOX,MAAA;QACT;QAIA,OAAO,GAAGA,MAAM,IAAIU,IAAI;MAC1B,CAAC;MAEDT,MAAA,CAAOW,IAAA,CAAKJ,eAAA,CAAgBK,IAAA,CAAK,IAAI,CAAC;IACxC,CAAC;IAGD,OAAOZ,MAAA,CAAOY,IAAA,CAAK;AAAA,EAAKb,MAAM;AAAA,CAAI;EACpC;EAEAc,YAAA,EAAc;IACZ,OAAO;MACLC,aAAA,EACEA,CAAA,KACA,CAAC;QAAEC;MAAS,MAAM;QAChB,OAAOA,QAAA,CAASC,MAAA,CAAO,KAAKrC,IAAI;MAClC;MACFsC,gBAAA,EACEA,CAAA,KACA,CAAC;QAAEF;MAAS,MAAM;QAChB,OAAOA,QAAA,CAASG,UAAA,CAAW,KAAKvC,IAAI;MACtC;MACFwC,eAAA,EACEA,CAAA,KACA,CAAC;QAAEJ;MAAS,MAAM;QAChB,OAAOA,QAAA,CAASK,IAAA,CAAK,KAAKzC,IAAI;MAChC;IACJ;EACF;EAEA0C,qBAAA,EAAuB;IACrB,OAAO;MACL,eAAeC,CAAA,KAAM,KAAKC,MAAA,CAAOR,QAAA,CAASE,gBAAA,CAAiB;IAC7D;EACF;EAEAO,cAAA,EAAgB;IACd,OAAO,CACLlD,iBAAA,CAAkB;MAChBmD,IAAA,EAAMjD,UAAA;MACNkD,IAAA,EAAM,KAAKA;IACb,CAAC,EACH;EACF;AACF,CAAC;;;ACtID,IAAOC,aAAA,GAAQlD,UAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}