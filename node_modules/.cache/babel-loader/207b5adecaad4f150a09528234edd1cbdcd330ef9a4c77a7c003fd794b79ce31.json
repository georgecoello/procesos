{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// src/code-block.ts\nimport { mergeAttributes, Node, textblockTypeInputRule } from \"@tiptap/core\";\nimport { Plugin, PluginKey, Selection, TextSelection } from \"@tiptap/pm/state\";\nvar DEFAULT_TAB_SIZE = 4;\nvar backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\nvar tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\nvar CodeBlock = Node.create({\n  name: \"codeBlock\",\n  addOptions() {\n    return {\n      languageClassPrefix: \"language-\",\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {}\n    };\n  },\n  content: \"text*\",\n  marks: \"\",\n  group: \"block\",\n  code: true,\n  defining: true,\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          var _a;\n          const {\n            languageClassPrefix\n          } = this.options;\n          if (!languageClassPrefix) {\n            return null;\n          }\n          const classNames = [...(((_a = element.firstElementChild) == null ? void 0 : _a.classList) || [])];\n          const languages = classNames.filter(className => className.startsWith(languageClassPrefix)).map(className => className.replace(languageClassPrefix, \"\"));\n          const language = languages[0];\n          if (!language) {\n            return null;\n          }\n          return language;\n        },\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"pre\",\n      preserveWhitespace: \"full\"\n    }];\n  },\n  renderHTML({\n    node,\n    HTMLAttributes\n  }) {\n    return [\"pre\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), [\"code\", {\n      class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n    }, 0]];\n  },\n  markdownTokenName: \"code\",\n  parseMarkdown: (token, helpers) => {\n    var _a;\n    if (((_a = token.raw) == null ? void 0 : _a.startsWith(\"```\")) === false && token.codeBlockStyle !== \"indented\") {\n      return [];\n    }\n    return helpers.createNode(\"codeBlock\", {\n      language: token.lang || null\n    }, token.text ? [helpers.createTextNode(token.text)] : []);\n  },\n  renderMarkdown: (node, h) => {\n    var _a;\n    let output = \"\";\n    const language = ((_a = node.attrs) == null ? void 0 : _a.language) || \"\";\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\n\n\\`\\`\\``;\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), \"```\"];\n      output = lines.join(\"\\n\");\n    }\n    return output;\n  },\n  addCommands() {\n    return {\n      setCodeBlock: attributes => ({\n        commands\n      }) => {\n        return commands.setNode(this.name, attributes);\n      },\n      toggleCodeBlock: attributes => ({\n        commands\n      }) => {\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-c\": () => this.editor.commands.toggleCodeBlock(),\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const {\n          empty,\n          $anchor\n        } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n        return false;\n      },\n      // handle tab indentation\n      Tab: ({\n        editor\n      }) => {\n        var _a;\n        if (!this.options.enableTabIndentation) {\n          return false;\n        }\n        const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n        const {\n          state\n        } = editor;\n        const {\n          selection\n        } = state;\n        const {\n          $from,\n          empty\n        } = selection;\n        if ($from.parent.type !== this.type) {\n          return false;\n        }\n        const indent = \" \".repeat(tabSize);\n        if (empty) {\n          return editor.commands.insertContent(indent);\n        }\n        return editor.commands.command(({\n          tr\n        }) => {\n          const {\n            from,\n            to\n          } = selection;\n          const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n          const lines = text.split(\"\\n\");\n          const indentedText = lines.map(line => indent + line).join(\"\\n\");\n          tr.replaceWith(from, to, state.schema.text(indentedText));\n          return true;\n        });\n      },\n      // handle shift+tab reverse indentation\n      \"Shift-Tab\": ({\n        editor\n      }) => {\n        var _a;\n        if (!this.options.enableTabIndentation) {\n          return false;\n        }\n        const tabSize = (_a = this.options.tabSize) != null ? _a : DEFAULT_TAB_SIZE;\n        const {\n          state\n        } = editor;\n        const {\n          selection\n        } = state;\n        const {\n          $from,\n          empty\n        } = selection;\n        if ($from.parent.type !== this.type) {\n          return false;\n        }\n        if (empty) {\n          return editor.commands.command(({\n            tr\n          }) => {\n            var _a2;\n            const {\n              pos\n            } = $from;\n            const codeBlockStart = $from.start();\n            const codeBlockEnd = $from.end();\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, \"\\n\", \"\\n\");\n            const lines = allText.split(\"\\n\");\n            let currentLineIndex = 0;\n            let charCount = 0;\n            const relativeCursorPos = pos - codeBlockStart;\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i;\n                break;\n              }\n              charCount += lines[i].length + 1;\n            }\n            const currentLine = lines[currentLineIndex];\n            const leadingSpaces = ((_a2 = currentLine.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n            if (spacesToRemove === 0) {\n              return true;\n            }\n            let lineStartPos = codeBlockStart;\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1;\n            }\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove);\n            const cursorPosInLine = pos - lineStartPos;\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos));\n            }\n            return true;\n          });\n        }\n        return editor.commands.command(({\n          tr\n        }) => {\n          const {\n            from,\n            to\n          } = selection;\n          const text = state.doc.textBetween(from, to, \"\\n\", \"\\n\");\n          const lines = text.split(\"\\n\");\n          const reverseIndentText = lines.map(line => {\n            var _a2;\n            const leadingSpaces = ((_a2 = line.match(/^ */)) == null ? void 0 : _a2[0]) || \"\";\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);\n            return line.slice(spacesToRemove);\n          }).join(\"\\n\");\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText));\n          return true;\n        });\n      },\n      // exit node on triple enter\n      Enter: ({\n        editor\n      }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false;\n        }\n        const {\n          state\n        } = editor;\n        const {\n          selection\n        } = state;\n        const {\n          $from,\n          empty\n        } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false;\n        }\n        return editor.chain().command(({\n          tr\n        }) => {\n          tr.delete($from.pos - 2, $from.pos);\n          return true;\n        }).exitCode().run();\n      },\n      // exit node on arrow down\n      ArrowDown: ({\n        editor\n      }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false;\n        }\n        const {\n          state\n        } = editor;\n        const {\n          selection,\n          doc\n        } = state;\n        const {\n          $from,\n          empty\n        } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        if (!isAtEnd) {\n          return false;\n        }\n        const after = $from.after();\n        if (after === void 0) {\n          return false;\n        }\n        const nodeAfter = doc.nodeAt(after);\n        if (nodeAfter) {\n          return editor.commands.command(({\n            tr\n          }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)));\n            return true;\n          });\n        }\n        return editor.commands.exitCode();\n      }\n    };\n  },\n  addInputRules() {\n    return [textblockTypeInputRule({\n      find: backtickInputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        language: match[1]\n      })\n    }), textblockTypeInputRule({\n      find: tildeInputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        language: match[1]\n      })\n    })];\n  },\n  addProseMirrorPlugins() {\n    return [\n    // this plugin creates a code block for pasted content from VS Code\n    // we can also detect the copied code language\n    new Plugin({\n      key: new PluginKey(\"codeBlockVSCodeHandler\"),\n      props: {\n        handlePaste: (view, event) => {\n          if (!event.clipboardData) {\n            return false;\n          }\n          if (this.editor.isActive(this.type.name)) {\n            return false;\n          }\n          const text = event.clipboardData.getData(\"text/plain\");\n          const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n          const vscodeData = vscode ? JSON.parse(vscode) : void 0;\n          const language = vscodeData == null ? void 0 : vscodeData.mode;\n          if (!text || !language) {\n            return false;\n          }\n          const {\n            tr,\n            schema\n          } = view.state;\n          const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n          tr.replaceSelectionWith(this.type.create({\n            language\n          }, textNode));\n          if (tr.selection.$from.parent.type !== this.type) {\n            tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n          }\n          tr.setMeta(\"paste\", true);\n          view.dispatch(tr);\n          return true;\n        }\n      }\n    })];\n  }\n});\n\n// src/index.ts\nvar index_default = CodeBlock;\nexport { CodeBlock, backtickInputRegex, index_default as default, tildeInputRegex };","map":{"version":3,"names":["mergeAttributes","Node","textblockTypeInputRule","Plugin","PluginKey","Selection","TextSelection","DEFAULT_TAB_SIZE","backtickInputRegex","tildeInputRegex","CodeBlock","create","name","addOptions","languageClassPrefix","exitOnTripleEnter","exitOnArrowDown","defaultLanguage","enableTabIndentation","tabSize","HTMLAttributes","content","marks","group","code","defining","addAttributes","language","default","options","parseHTML","element","_a","classNames","firstElementChild","classList","languages","filter","className","startsWith","map","replace","rendered","tag","preserveWhitespace","renderHTML","node","class","attrs","markdownTokenName","parseMarkdown","token","helpers","raw","codeBlockStyle","createNode","lang","text","createTextNode","renderMarkdown","h","output","lines","renderChildren","join","addCommands","setCodeBlock","attributes","commands","setNode","toggleCodeBlock","toggleNode","addKeyboardShortcuts","Mod-Alt-c","editor","Backspace","empty","$anchor","state","selection","isAtStart","pos","parent","type","textContent","length","clearNodes","Tab","$from","indent","repeat","insertContent","command","tr","from","to","doc","textBetween","split","indentedText","line","replaceWith","schema","Shift-Tab","_a2","codeBlockStart","start","codeBlockEnd","end","allText","currentLineIndex","charCount","relativeCursorPos","i","currentLine","leadingSpaces","match","spacesToRemove","Math","min","lineStartPos","delete","cursorPosInLine","setSelection","reverseIndentText","slice","Enter","isAtEnd","parentOffset","nodeSize","endsWithDoubleNewline","endsWith","chain","exitCode","run","ArrowDown","after","nodeAfter","nodeAt","near","resolve","addInputRules","find","getAttributes","addProseMirrorPlugins","key","props","handlePaste","view","event","clipboardData","isActive","getData","vscode","vscodeData","JSON","parse","mode","textNode","replaceSelectionWith","max","setMeta","dispatch","index_default"],"sources":["../src/code-block.ts","../src/index.ts"],"sourcesContent":["import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, Selection, TextSelection } from '@tiptap/pm/state'\n\nconst DEFAULT_TAB_SIZE = 4\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * @default 'language-'\n   */\n  languageClassPrefix: string | null | undefined\n  /**\n   * Define whether the node should be exited on triple enter.\n   * @default true\n   */\n  exitOnTripleEnter: boolean | null | undefined\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * @default true\n   */\n  exitOnArrowDown: boolean | null | undefined\n  /**\n   * The default language.\n   * @default null\n   * @example 'js'\n   */\n  defaultLanguage: string | null | undefined\n  /**\n   * Enable tab key for indentation in code blocks.\n   * @default false\n   */\n  enableTabIndentation: boolean | null | undefined\n  /**\n   * The number of spaces to use for tab indentation.\n   * @default 4\n   */\n  tabSize: number | null | undefined\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.setCodeBlock({ language: 'javascript' })\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType\n      /**\n       * Toggle a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.toggleCodeBlock({ language: 'javascript' })\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a code block with backticks.\n */\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\n\n/**\n * Matches a code block with tildes.\n */\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n\n          if (!languageClassPrefix) {\n            return null\n          }\n\n          const classNames = [...(element.firstElementChild?.classList || [])]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  markdownTokenName: 'code',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.raw?.startsWith('```') === false && token.codeBlockStyle !== 'indented') {\n      return []\n    }\n\n    return helpers.createNode(\n      'codeBlock',\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : [],\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    let output = ''\n    const language = node.attrs?.language || ''\n\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\\n\\n\\`\\`\\``\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), '```']\n      output = lines.join('\\n')\n    }\n\n    return output\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.setNode(this.name, attributes)\n        },\n      toggleCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        const indent = ' '.repeat(tabSize)\n\n        if (empty) {\n          return editor.commands.insertContent(indent)\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const indentedText = lines.map(line => indent + line).join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(indentedText))\n          return true\n        })\n      },\n\n      // handle shift+tab reverse indentation\n      'Shift-Tab': ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            const { pos } = $from\n            const codeBlockStart = $from.start()\n            const codeBlockEnd = $from.end()\n\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, '\\n', '\\n')\n            const lines = allText.split('\\n')\n\n            let currentLineIndex = 0\n            let charCount = 0\n            const relativeCursorPos = pos - codeBlockStart\n\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i\n                break\n              }\n              charCount += lines[i].length + 1\n            }\n\n            const currentLine = lines[currentLineIndex]\n            const leadingSpaces = currentLine.match(/^ */)?.[0] || ''\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n\n            if (spacesToRemove === 0) {\n              return true\n            }\n\n            let lineStartPos = codeBlockStart\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1\n            }\n\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove)\n\n            const cursorPosInLine = pos - lineStartPos\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos))\n            }\n\n            return true\n          })\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const reverseIndentText = lines\n            .map(line => {\n              const leadingSpaces = line.match(/^ */)?.[0] || ''\n              const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n              return line.slice(spacesToRemove)\n            })\n            .join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText))\n          return true\n        })\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)))\n            return true\n          })\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // donâ€™t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode ? JSON.parse(vscode) : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr, schema } = view.state\n\n            // prepare a text node\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'))\n\n            // create a code block with the text node\n            // replace selection with the code block\n            tr.replaceSelectionWith(this.type.create({ language }, textNode))\n\n            if (tr.selection.$from.parent.type !== this.type) {\n              // put cursor inside the newly created code block\n              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n            }\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { CodeBlock } from './code-block.js'\n\nexport * from './code-block.js'\n\nexport default CodeBlock\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}