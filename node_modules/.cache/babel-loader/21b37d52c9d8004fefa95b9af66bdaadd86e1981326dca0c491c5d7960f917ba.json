{"ast":null,"code":"// src/horizontal-rule.ts\nimport { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from \"@tiptap/core\";\nimport { NodeSelection, TextSelection } from \"@tiptap/pm/state\";\nvar HorizontalRule = Node.create({\n  name: \"horizontalRule\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: \"paragraph\"\n    };\n  },\n  group: \"block\",\n  parseHTML() {\n    return [{\n      tag: \"hr\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"hr\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  markdownTokenName: \"hr\",\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode(\"horizontalRule\");\n  },\n  renderMarkdown: () => {\n    return \"---\";\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain,\n        state\n      }) => {\n        if (!canInsertNode(state, state.schema.nodes[this.name])) {\n          return false;\n        }\n        const {\n          selection\n        } = state;\n        const {\n          $to: $originTo\n        } = selection;\n        const currentChain = chain();\n        if (isNodeSelection(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({\n            type: this.name\n          });\n        }\n        return currentChain.command(({\n          state: chainState,\n          tr,\n          dispatch\n        }) => {\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;\n              const node = nodeType == null ? void 0 : nodeType.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\n\n// src/index.ts\nvar index_default = HorizontalRule;\nexport { HorizontalRule, index_default as default };","map":{"version":3,"names":["canInsertNode","isNodeSelection","mergeAttributes","Node","nodeInputRule","NodeSelection","TextSelection","HorizontalRule","create","name","addOptions","HTMLAttributes","nextNodeType","group","parseHTML","tag","renderHTML","options","markdownTokenName","parseMarkdown","token","helpers","createNode","renderMarkdown","addCommands","setHorizontalRule","chain","state","schema","nodes","selection","$to","$originTo","currentChain","insertContentAt","pos","type","insertContent","command","chainState","tr","dispatch","posAfter","end","nodeAfter","isTextblock","setSelection","doc","isBlock","nodeType","parent","contentMatch","defaultType","node","insert","scrollIntoView","run","addInputRules","find","index_default"],"sources":["../src/horizontal-rule.ts","../src/index.ts"],"sourcesContent":["import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * The default type to insert after the horizontal rule.\n   * @default \"paragraph\"\n   * @example \"heading\"\n   */\n  nextNodeType: string\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: 'paragraph',\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  markdownTokenName: 'hr',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('horizontalRule')\n  },\n\n  renderMarkdown: () => {\n    return '---'\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ state: chainState, tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const nodeType =\n                      chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType\n                    const node = nodeType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { HorizontalRule } from './horizontal-rule.js'\n\nexport * from './horizontal-rule.js'\n\nexport default HorizontalRule\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}