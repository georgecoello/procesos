{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\n// src/services/storageService.js\n\n/**\n * Servicio de almacenamiento para documentos y versiones\n * Maneja localStorage, IndexedDB y sincronizaci√≥n\n */\nexport class StorageService {\n  constructor() {\n    this.STORAGE_PREFIX = 'doc_system_';\n    this.MAX_LOCAL_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB\n    this.indexedDB = null;\n    this.isIndexedDBSupported = 'indexedDB' in window;\n  }\n\n  /**\n   * Inicializa el servicio de almacenamiento\n   */\n  async initialize() {\n    if (this.isIndexedDBSupported) {\n      await this.initializeIndexedDB();\n    }\n\n    // Limpiar datos antiguos peri√≥dicamente\n    this.cleanupOldData();\n    console.log('‚úÖ StorageService inicializado');\n    return true;\n  }\n\n  /**\n   * ============ LOCALSTORAGE METHODS ============\n   */\n\n  /**\n   * Guarda datos en localStorage\n   */\n  saveToLocalStorage(key, data, options = {}) {\n    try {\n      const storageKey = this.STORAGE_PREFIX + key;\n      const storageData = {\n        data: data,\n        metadata: {\n          savedAt: new Date().toISOString(),\n          version: options.version || '1.0',\n          expiresAt: options.expiresAt || null,\n          size: JSON.stringify(data).length\n        }\n      };\n      localStorage.setItem(storageKey, JSON.stringify(storageData));\n\n      // Actualizar √≠ndice de documentos\n      this.updateDocumentIndex(key, {\n        title: options.title,\n        type: options.type || 'document',\n        lastModified: new Date().toISOString(),\n        size: storageData.metadata.size\n      });\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error guardando en localStorage:', error);\n\n      // Si localStorage est√° lleno, intentar limpiar\n      if (error.name === 'QuotaExceededError') {\n        this.handleStorageFull();\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Carga datos desde localStorage\n   */\n  loadFromLocalStorage(key) {\n    try {\n      const storageKey = this.STORAGE_PREFIX + key;\n      const stored = localStorage.getItem(storageKey);\n      if (!stored) return null;\n      const parsed = JSON.parse(stored);\n\n      // Verificar si ha expirado\n      if (parsed.metadata.expiresAt && new Date(parsed.metadata.expiresAt) < new Date()) {\n        localStorage.removeItem(storageKey);\n        return null;\n      }\n      return parsed.data;\n    } catch (error) {\n      console.error('‚ùå Error cargando de localStorage:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Elimina datos de localStorage\n   */\n  removeFromLocalStorage(key) {\n    try {\n      const storageKey = this.STORAGE_PREFIX + key;\n      localStorage.removeItem(storageKey);\n\n      // Actualizar √≠ndice\n      this.removeFromDocumentIndex(key);\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error eliminando de localStorage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * ============ INDEXEDDB METHODS ============\n   */\n\n  /**\n   * Inicializa IndexedDB\n   */\n  async initializeIndexedDB() {\n    return new Promise((resolve, reject) => {\n      if (!this.isIndexedDBSupported) {\n        resolve(false);\n        return;\n      }\n      const request = indexedDB.open('DocumentStorageDB', 1);\n      request.onerror = event => {\n        console.error('‚ùå Error abriendo IndexedDB:', event.target.error);\n        reject(event.target.error);\n      };\n      request.onsuccess = event => {\n        this.indexedDB = event.target.result;\n        console.log('‚úÖ IndexedDB inicializado');\n        resolve(true);\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n\n        // Crear store para documentos\n        if (!db.objectStoreNames.contains('documents')) {\n          const documentStore = db.createObjectStore('documents', {\n            keyPath: 'id'\n          });\n          documentStore.createIndex('createdAt', 'createdAt', {\n            unique: false\n          });\n          documentStore.createIndex('type', 'type', {\n            unique: false\n          });\n        }\n\n        // Crear store para versiones\n        if (!db.objectStoreNames.contains('versions')) {\n          const versionStore = db.createObjectStore('versions', {\n            keyPath: 'id'\n          });\n          versionStore.createIndex('documentId', 'documentId', {\n            unique: false\n          });\n          versionStore.createIndex('createdAt', 'createdAt', {\n            unique: false\n          });\n        }\n\n        // Crear store para metadata\n        if (!db.objectStoreNames.contains('metadata')) {\n          db.createObjectStore('metadata', {\n            keyPath: 'key'\n          });\n        }\n      };\n    });\n  }\n\n  /**\n   * Guarda datos en IndexedDB\n   */\n  async saveToIndexedDB(storeName, data) {\n    if (!this.isIndexedDBSupported || !this.indexedDB) {\n      throw new Error('IndexedDB no disponible');\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB.transaction([storeName], 'readwrite');\n      const store = transaction.objectStore(storeName);\n\n      // Agregar metadatos\n      const enhancedData = {\n        ...data,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      const request = store.put(enhancedData);\n      request.onsuccess = () => {\n        resolve(enhancedData.id);\n      };\n      request.onerror = event => {\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * Carga datos desde IndexedDB\n   */\n  async loadFromIndexedDB(storeName, id) {\n    if (!this.isIndexedDBSupported || !this.indexedDB) {\n      throw new Error('IndexedDB no disponible');\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB.transaction([storeName], 'readonly');\n      const store = transaction.objectStore(storeName);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * ============ DOCUMENT MANAGEMENT ============\n   */\n\n  /**\n   * Guarda un documento completo\n   */\n  async saveDocument(documentData, options = {}) {\n    const documentId = options.documentId || `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Calcular tama√±o\n    const size = JSON.stringify(documentData).length;\n\n    // Decidir d√≥nde guardar basado en el tama√±o\n    if (size > 2 * 1024 * 1024) {\n      // M√°s de 2MB\n      // Guardar en IndexedDB\n      if (this.isIndexedDBSupported) {\n        const savedId = await this.saveToIndexedDB('documents', {\n          id: documentId,\n          data: documentData,\n          metadata: {\n            title: options.title || 'Documento sin t√≠tulo',\n            type: options.type || 'policy_document',\n            size: size,\n            version: options.version || '1.0'\n          }\n        });\n\n        // Guardar referencia en localStorage\n        this.saveToLocalStorage(`ref_${documentId}`, {\n          storage: 'indexeddb',\n          store: 'documents',\n          id: savedId,\n          size: size\n        }, {\n          title: options.title,\n          type: 'document_reference'\n        });\n        return documentId;\n      }\n    }\n\n    // Guardar en localStorage (documentos peque√±os)\n    this.saveToLocalStorage(documentId, documentData, {\n      title: options.title,\n      type: options.type || 'policy_document',\n      version: options.version\n    });\n    return documentId;\n  }\n\n  /**\n   * Carga un documento\n   */\n  async loadDocument(documentId) {\n    // Primero intentar cargar desde localStorage\n    const localData = this.loadFromLocalStorage(documentId);\n    if (localData) return localData;\n\n    // Si no est√° en localStorage, buscar referencia\n    const refData = this.loadFromLocalStorage(`ref_${documentId}`);\n    if (refData && refData.storage === 'indexeddb') {\n      const indexedDBData = await this.loadFromIndexedDB(refData.store, refData.id);\n      return indexedDBData?.data || null;\n    }\n    return null;\n  }\n\n  /**\n   * ============ VERSION MANAGEMENT ============\n   */\n\n  /**\n   * Guarda versiones de un documento\n   */\n  saveDocumentVersions(documentId, versions) {\n    const versionsData = {\n      documentId: documentId,\n      versions: versions,\n      lastUpdated: new Date().toISOString(),\n      count: versions.length\n    };\n    return this.saveToLocalStorage(`versions_${documentId}`, versionsData, {\n      title: `Versiones de ${documentId}`,\n      type: 'versions'\n    });\n  }\n\n  /**\n   * Carga versiones de un documento\n   */\n  loadDocumentVersions(documentId) {\n    const versionsData = this.loadFromLocalStorage(`versions_${documentId}`);\n    return versionsData?.versions || [];\n  }\n\n  /**\n   * ============ BACKUP & RECOVERY ============\n   */\n\n  /**\n   * Crea un backup completo\n   */\n  async createBackup() {\n    const backup = {\n      timestamp: new Date().toISOString(),\n      documents: [],\n      versions: [],\n      metadata: {\n        totalSize: 0,\n        documentCount: 0,\n        versionCount: 0\n      }\n    };\n\n    // Recolectar todos los documentos\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.startsWith(this.STORAGE_PREFIX)) {\n        const cleanKey = key.replace(this.STORAGE_PREFIX, '');\n        const data = this.loadFromLocalStorage(cleanKey);\n        if (data) {\n          backup.documents.push({\n            key: cleanKey,\n            data: data\n          });\n          backup.metadata.documentCount++;\n          backup.metadata.totalSize += JSON.stringify(data).length;\n        }\n      }\n    }\n\n    // Recolectar versiones\n    const allKeys = Object.keys(localStorage).filter(key => key.includes('versions_') && key.startsWith(this.STORAGE_PREFIX));\n    for (const key of allKeys) {\n      const cleanKey = key.replace(this.STORAGE_PREFIX, '');\n      const versions = this.loadFromLocalStorage(cleanKey);\n      if (versions) {\n        backup.versions.push({\n          key: cleanKey,\n          data: versions\n        });\n        backup.metadata.versionCount++;\n        backup.metadata.totalSize += JSON.stringify(versions).length;\n      }\n    }\n    return backup;\n  }\n\n  /**\n   * Restaura desde un backup\n   */\n  async restoreFromBackup(backupData, options = {}) {\n    const {\n      overwrite = false,\n      merge = true\n    } = options;\n    if (!overwrite && !merge) {\n      throw new Error('Se necesita especificar overwrite o merge');\n    }\n    let restoredCount = 0;\n\n    // Restaurar documentos\n    for (const doc of backupData.documents) {\n      const existing = this.loadFromLocalStorage(doc.key);\n      if (!existing || overwrite) {\n        this.saveToLocalStorage(doc.key, doc.data, {\n          title: `Restaurado ${new Date().toLocaleDateString()}`,\n          type: 'restored_document'\n        });\n        restoredCount++;\n      } else if (merge) {\n        // L√≥gica de merge (simplificada)\n        const merged = this.mergeDocuments(existing, doc.data);\n        this.saveToLocalStorage(doc.key, merged);\n        restoredCount++;\n      }\n    }\n\n    // Restaurar versiones\n    for (const version of backupData.versions) {\n      const existing = this.loadFromLocalStorage(version.key);\n      if (!existing || overwrite) {\n        this.saveToLocalStorage(version.key, version.data);\n        restoredCount++;\n      }\n    }\n    return {\n      success: true,\n      restoredCount: restoredCount,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * ============ UTILITY METHODS ============\n   */\n\n  /**\n   * Actualiza el √≠ndice de documentos\n   */\n  updateDocumentIndex(key, metadata) {\n    try {\n      const index = this.loadFromLocalStorage('document_index') || [];\n      const existingIndex = index.findIndex(item => item.key === key);\n      if (existingIndex >= 0) {\n        index[existingIndex] = {\n          ...index[existingIndex],\n          ...metadata,\n          lastModified: new Date().toISOString()\n        };\n      } else {\n        index.push({\n          key: key,\n          ...metadata,\n          created: new Date().toISOString(),\n          lastModified: new Date().toISOString()\n        });\n      }\n      this.saveToLocalStorage('document_index', index, {\n        title: '√çndice de documentos',\n        type: 'system_index'\n      });\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error actualizando √≠ndice:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Elimina del √≠ndice de documentos\n   */\n  removeFromDocumentIndex(key) {\n    try {\n      const index = this.loadFromLocalStorage('document_index') || [];\n      const newIndex = index.filter(item => item.key !== key);\n      this.saveToLocalStorage('document_index', newIndex, {\n        title: '√çndice de documentos',\n        type: 'system_index'\n      });\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error eliminando del √≠ndice:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Obtiene todos los documentos\n   */\n  getAllDocuments() {\n    const index = this.loadFromLocalStorage('document_index') || [];\n    return index;\n  }\n\n  /**\n   * Maneja almacenamiento lleno\n   */\n  handleStorageFull() {\n    console.warn('‚ö†Ô∏è localStorage casi lleno, limpiando datos antiguos...');\n\n    // Eliminar datos antiguos primero\n    this.cleanupOldData(true);\n\n    // Si todav√≠a est√° lleno, eliminar versiones antiguas\n    const index = this.getAllDocuments();\n    const oldVersions = index.filter(item => item.type === 'versions' && item.lastModified && new Date(item.lastModified) < new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30 d√≠as\n    );\n    oldVersions.forEach(item => {\n      this.removeFromLocalStorage(item.key);\n    });\n    console.log(`üóëÔ∏è ${oldVersions.length} versiones antiguas eliminadas`);\n  }\n\n  /**\n   * Limpia datos antiguos\n   */\n  cleanupOldData(force = false) {\n    const now = new Date();\n    const index = this.getAllDocuments();\n    let cleanedCount = 0;\n    index.forEach(item => {\n      if (item.expiresAt) {\n        const expiresDate = new Date(item.expiresAt);\n        if (expiresDate < now || force) {\n          this.removeFromLocalStorage(item.key);\n          cleanedCount++;\n        }\n      }\n    });\n    if (cleanedCount > 0) {\n      console.log(`üßπ ${cleanedCount} documentos expirados eliminados`);\n    }\n  }\n\n  /**\n   * Obtiene estad√≠sticas de almacenamiento\n   */\n  getStorageStats() {\n    let totalSize = 0;\n    const index = this.getAllDocuments();\n    index.forEach(item => {\n      const data = this.loadFromLocalStorage(item.key);\n      if (data) {\n        totalSize += JSON.stringify(data).length;\n      }\n    });\n    return {\n      totalDocuments: index.length,\n      totalSize: this.formatSize(totalSize),\n      localStorageUsage: this.formatSize(totalSize),\n      localStorageLimit: this.formatSize(this.MAX_LOCAL_STORAGE_SIZE),\n      usagePercentage: (totalSize / this.MAX_LOCAL_STORAGE_SIZE * 100).toFixed(2) + '%'\n    };\n  }\n\n  /**\n   * Formatea tama√±o en bytes a texto legible\n   */\n  formatSize(bytes) {\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n  }\n\n  /**\n   * Merge de documentos (estrategia simple)\n   */\n  mergeDocuments(doc1, doc2) {\n    // Estrategia simple: preferir doc2 sobre doc1\n    return {\n      ...doc1,\n      ...doc2,\n      metadata: {\n        ...doc1.metadata,\n        ...doc2.metadata,\n        mergedAt: new Date().toISOString()\n      }\n    };\n  }\n}\n\n/**\n * Instancia singleton del StorageService\n */\nlet storageServiceInstance = null;\n\n/**\n * Obtiene la instancia √∫nica del StorageService\n */\nexport function getStorageService() {\n  if (!storageServiceInstance) {\n    storageServiceInstance = new StorageService();\n    storageServiceInstance.initialize();\n  }\n  return storageServiceInstance;\n}\n\n/**\n * Utilidades de exportaci√≥n/importaci√≥n\n */\nexport const StorageUtils = {\n  /**\n   * Exporta todos los datos como archivo\n   */\n  async exportAllData() {\n    const service = getStorageService();\n    const backup = await service.createBackup();\n    const blob = new Blob([JSON.stringify(backup, null, 2)], {\n      type: 'application/json'\n    });\n    return {\n      blob: blob,\n      filename: `backup_documents_${new Date().toISOString().split('T')[0]}.json`,\n      stats: backup.metadata\n    };\n  },\n  /**\n   * Importa datos desde un archivo\n   */\n  async importFromFile(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = async event => {\n        try {\n          const backupData = JSON.parse(event.target.result);\n          const service = getStorageService();\n          const result = await service.restoreFromBackup(backupData);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      reader.onerror = () => {\n        reject(new Error('Error leyendo el archivo'));\n      };\n      reader.readAsText(file);\n    });\n  },\n  /**\n   * Limpia todos los datos del sistema\n   */\n  async clearAllData() {\n    if (confirm('‚ö†Ô∏è ¬øEST√ÅS SEGURO? Esto eliminar√° TODOS los documentos y versiones. Esta acci√≥n NO se puede deshacer.')) {\n      const service = getStorageService();\n      const index = service.getAllDocuments();\n      index.forEach(item => {\n        service.removeFromLocalStorage(item.key);\n      });\n      localStorage.removeItem('document_index');\n      return {\n        success: true,\n        cleared: index.length,\n        message: 'Todos los datos han sido eliminados'\n      };\n    }\n    return {\n      success: false,\n      message: 'Operaci√≥n cancelada'\n    };\n  }\n};","map":{"version":3,"names":["StorageService","constructor","STORAGE_PREFIX","MAX_LOCAL_STORAGE_SIZE","indexedDB","isIndexedDBSupported","window","initialize","initializeIndexedDB","cleanupOldData","console","log","saveToLocalStorage","key","data","options","storageKey","storageData","metadata","savedAt","Date","toISOString","version","expiresAt","size","JSON","stringify","length","localStorage","setItem","updateDocumentIndex","title","type","lastModified","error","name","handleStorageFull","loadFromLocalStorage","stored","getItem","parsed","parse","removeItem","removeFromLocalStorage","removeFromDocumentIndex","Promise","resolve","reject","request","open","onerror","event","target","onsuccess","result","onupgradeneeded","db","objectStoreNames","contains","documentStore","createObjectStore","keyPath","createIndex","unique","versionStore","saveToIndexedDB","storeName","Error","transaction","store","objectStore","enhancedData","createdAt","updatedAt","put","id","loadFromIndexedDB","get","saveDocument","documentData","documentId","now","Math","random","toString","substr","savedId","storage","loadDocument","localData","refData","indexedDBData","saveDocumentVersions","versions","versionsData","lastUpdated","count","loadDocumentVersions","createBackup","backup","timestamp","documents","totalSize","documentCount","versionCount","i","startsWith","cleanKey","replace","push","allKeys","Object","keys","filter","includes","restoreFromBackup","backupData","overwrite","merge","restoredCount","doc","existing","toLocaleDateString","merged","mergeDocuments","success","index","existingIndex","findIndex","item","created","newIndex","getAllDocuments","warn","oldVersions","forEach","force","cleanedCount","expiresDate","getStorageStats","totalDocuments","formatSize","localStorageUsage","localStorageLimit","usagePercentage","toFixed","bytes","doc1","doc2","mergedAt","storageServiceInstance","getStorageService","StorageUtils","exportAllData","service","blob","Blob","filename","split","stats","importFromFile","file","reader","FileReader","onload","readAsText","clearAllData","confirm","cleared","message"],"sources":["/home/jorge/Escritorio/Jorge-PC/procesos/procesos/src/services/storageServices.js"],"sourcesContent":["// src/services/storageService.js\n\n/**\n * Servicio de almacenamiento para documentos y versiones\n * Maneja localStorage, IndexedDB y sincronizaci√≥n\n */\nexport class StorageService {\n  constructor() {\n    this.STORAGE_PREFIX = 'doc_system_';\n    this.MAX_LOCAL_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB\n    this.indexedDB = null;\n    this.isIndexedDBSupported = 'indexedDB' in window;\n  }\n\n  /**\n   * Inicializa el servicio de almacenamiento\n   */\n  async initialize() {\n    if (this.isIndexedDBSupported) {\n      await this.initializeIndexedDB();\n    }\n    \n    // Limpiar datos antiguos peri√≥dicamente\n    this.cleanupOldData();\n    \n    console.log('‚úÖ StorageService inicializado');\n    return true;\n  }\n\n  /**\n   * ============ LOCALSTORAGE METHODS ============\n   */\n\n  /**\n   * Guarda datos en localStorage\n   */\n  saveToLocalStorage(key, data, options = {}) {\n    try {\n      const storageKey = this.STORAGE_PREFIX + key;\n      const storageData = {\n        data: data,\n        metadata: {\n          savedAt: new Date().toISOString(),\n          version: options.version || '1.0',\n          expiresAt: options.expiresAt || null,\n          size: JSON.stringify(data).length\n        }\n      };\n      \n      localStorage.setItem(storageKey, JSON.stringify(storageData));\n      \n      // Actualizar √≠ndice de documentos\n      this.updateDocumentIndex(key, {\n        title: options.title,\n        type: options.type || 'document',\n        lastModified: new Date().toISOString(),\n        size: storageData.metadata.size\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('‚ùå Error guardando en localStorage:', error);\n      \n      // Si localStorage est√° lleno, intentar limpiar\n      if (error.name === 'QuotaExceededError') {\n        this.handleStorageFull();\n      }\n      \n      return false;\n    }\n  }\n\n  /**\n   * Carga datos desde localStorage\n   */\n  loadFromLocalStorage(key) {\n    try {\n      const storageKey = this.STORAGE_PREFIX + key;\n      const stored = localStorage.getItem(storageKey);\n      \n      if (!stored) return null;\n      \n      const parsed = JSON.parse(stored);\n      \n      // Verificar si ha expirado\n      if (parsed.metadata.expiresAt && new Date(parsed.metadata.expiresAt) < new Date()) {\n        localStorage.removeItem(storageKey);\n        return null;\n      }\n      \n      return parsed.data;\n    } catch (error) {\n      console.error('‚ùå Error cargando de localStorage:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Elimina datos de localStorage\n   */\n  removeFromLocalStorage(key) {\n    try {\n      const storageKey = this.STORAGE_PREFIX + key;\n      localStorage.removeItem(storageKey);\n      \n      // Actualizar √≠ndice\n      this.removeFromDocumentIndex(key);\n      \n      return true;\n    } catch (error) {\n      console.error('‚ùå Error eliminando de localStorage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * ============ INDEXEDDB METHODS ============\n   */\n\n  /**\n   * Inicializa IndexedDB\n   */\n  async initializeIndexedDB() {\n    return new Promise((resolve, reject) => {\n      if (!this.isIndexedDBSupported) {\n        resolve(false);\n        return;\n      }\n\n      const request = indexedDB.open('DocumentStorageDB', 1);\n\n      request.onerror = (event) => {\n        console.error('‚ùå Error abriendo IndexedDB:', event.target.error);\n        reject(event.target.error);\n      };\n\n      request.onsuccess = (event) => {\n        this.indexedDB = event.target.result;\n        console.log('‚úÖ IndexedDB inicializado');\n        resolve(true);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // Crear store para documentos\n        if (!db.objectStoreNames.contains('documents')) {\n          const documentStore = db.createObjectStore('documents', { keyPath: 'id' });\n          documentStore.createIndex('createdAt', 'createdAt', { unique: false });\n          documentStore.createIndex('type', 'type', { unique: false });\n        }\n        \n        // Crear store para versiones\n        if (!db.objectStoreNames.contains('versions')) {\n          const versionStore = db.createObjectStore('versions', { keyPath: 'id' });\n          versionStore.createIndex('documentId', 'documentId', { unique: false });\n          versionStore.createIndex('createdAt', 'createdAt', { unique: false });\n        }\n        \n        // Crear store para metadata\n        if (!db.objectStoreNames.contains('metadata')) {\n          db.createObjectStore('metadata', { keyPath: 'key' });\n        }\n      };\n    });\n  }\n\n  /**\n   * Guarda datos en IndexedDB\n   */\n  async saveToIndexedDB(storeName, data) {\n    if (!this.isIndexedDBSupported || !this.indexedDB) {\n      throw new Error('IndexedDB no disponible');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB.transaction([storeName], 'readwrite');\n      const store = transaction.objectStore(storeName);\n      \n      // Agregar metadatos\n      const enhancedData = {\n        ...data,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      \n      const request = store.put(enhancedData);\n\n      request.onsuccess = () => {\n        resolve(enhancedData.id);\n      };\n\n      request.onerror = (event) => {\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * Carga datos desde IndexedDB\n   */\n  async loadFromIndexedDB(storeName, id) {\n    if (!this.isIndexedDBSupported || !this.indexedDB) {\n      throw new Error('IndexedDB no disponible');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.indexedDB.transaction([storeName], 'readonly');\n      const store = transaction.objectStore(storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result);\n      };\n\n      request.onerror = (event) => {\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * ============ DOCUMENT MANAGEMENT ============\n   */\n\n  /**\n   * Guarda un documento completo\n   */\n  async saveDocument(documentData, options = {}) {\n    const documentId = options.documentId || `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Calcular tama√±o\n    const size = JSON.stringify(documentData).length;\n    \n    // Decidir d√≥nde guardar basado en el tama√±o\n    if (size > 2 * 1024 * 1024) { // M√°s de 2MB\n      // Guardar en IndexedDB\n      if (this.isIndexedDBSupported) {\n        const savedId = await this.saveToIndexedDB('documents', {\n          id: documentId,\n          data: documentData,\n          metadata: {\n            title: options.title || 'Documento sin t√≠tulo',\n            type: options.type || 'policy_document',\n            size: size,\n            version: options.version || '1.0'\n          }\n        });\n        \n        // Guardar referencia en localStorage\n        this.saveToLocalStorage(`ref_${documentId}`, {\n          storage: 'indexeddb',\n          store: 'documents',\n          id: savedId,\n          size: size\n        }, {\n          title: options.title,\n          type: 'document_reference'\n        });\n        \n        return documentId;\n      }\n    }\n    \n    // Guardar en localStorage (documentos peque√±os)\n    this.saveToLocalStorage(documentId, documentData, {\n      title: options.title,\n      type: options.type || 'policy_document',\n      version: options.version\n    });\n    \n    return documentId;\n  }\n\n  /**\n   * Carga un documento\n   */\n  async loadDocument(documentId) {\n    // Primero intentar cargar desde localStorage\n    const localData = this.loadFromLocalStorage(documentId);\n    if (localData) return localData;\n    \n    // Si no est√° en localStorage, buscar referencia\n    const refData = this.loadFromLocalStorage(`ref_${documentId}`);\n    if (refData && refData.storage === 'indexeddb') {\n      const indexedDBData = await this.loadFromIndexedDB(refData.store, refData.id);\n      return indexedDBData?.data || null;\n    }\n    \n    return null;\n  }\n\n  /**\n   * ============ VERSION MANAGEMENT ============\n   */\n\n  /**\n   * Guarda versiones de un documento\n   */\n  saveDocumentVersions(documentId, versions) {\n    const versionsData = {\n      documentId: documentId,\n      versions: versions,\n      lastUpdated: new Date().toISOString(),\n      count: versions.length\n    };\n    \n    return this.saveToLocalStorage(`versions_${documentId}`, versionsData, {\n      title: `Versiones de ${documentId}`,\n      type: 'versions'\n    });\n  }\n\n  /**\n   * Carga versiones de un documento\n   */\n  loadDocumentVersions(documentId) {\n    const versionsData = this.loadFromLocalStorage(`versions_${documentId}`);\n    return versionsData?.versions || [];\n  }\n\n  /**\n   * ============ BACKUP & RECOVERY ============\n   */\n\n  /**\n   * Crea un backup completo\n   */\n  async createBackup() {\n    const backup = {\n      timestamp: new Date().toISOString(),\n      documents: [],\n      versions: [],\n      metadata: {\n        totalSize: 0,\n        documentCount: 0,\n        versionCount: 0\n      }\n    };\n    \n    // Recolectar todos los documentos\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      \n      if (key.startsWith(this.STORAGE_PREFIX)) {\n        const cleanKey = key.replace(this.STORAGE_PREFIX, '');\n        const data = this.loadFromLocalStorage(cleanKey);\n        \n        if (data) {\n          backup.documents.push({\n            key: cleanKey,\n            data: data\n          });\n          backup.metadata.documentCount++;\n          backup.metadata.totalSize += JSON.stringify(data).length;\n        }\n      }\n    }\n    \n    // Recolectar versiones\n    const allKeys = Object.keys(localStorage).filter(key => \n      key.includes('versions_') && key.startsWith(this.STORAGE_PREFIX)\n    );\n    \n    for (const key of allKeys) {\n      const cleanKey = key.replace(this.STORAGE_PREFIX, '');\n      const versions = this.loadFromLocalStorage(cleanKey);\n      \n      if (versions) {\n        backup.versions.push({\n          key: cleanKey,\n          data: versions\n        });\n        backup.metadata.versionCount++;\n        backup.metadata.totalSize += JSON.stringify(versions).length;\n      }\n    }\n    \n    return backup;\n  }\n\n  /**\n   * Restaura desde un backup\n   */\n  async restoreFromBackup(backupData, options = {}) {\n    const { overwrite = false, merge = true } = options;\n    \n    if (!overwrite && !merge) {\n      throw new Error('Se necesita especificar overwrite o merge');\n    }\n    \n    let restoredCount = 0;\n    \n    // Restaurar documentos\n    for (const doc of backupData.documents) {\n      const existing = this.loadFromLocalStorage(doc.key);\n      \n      if (!existing || overwrite) {\n        this.saveToLocalStorage(doc.key, doc.data, {\n          title: `Restaurado ${new Date().toLocaleDateString()}`,\n          type: 'restored_document'\n        });\n        restoredCount++;\n      } else if (merge) {\n        // L√≥gica de merge (simplificada)\n        const merged = this.mergeDocuments(existing, doc.data);\n        this.saveToLocalStorage(doc.key, merged);\n        restoredCount++;\n      }\n    }\n    \n    // Restaurar versiones\n    for (const version of backupData.versions) {\n      const existing = this.loadFromLocalStorage(version.key);\n      \n      if (!existing || overwrite) {\n        this.saveToLocalStorage(version.key, version.data);\n        restoredCount++;\n      }\n    }\n    \n    return {\n      success: true,\n      restoredCount: restoredCount,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * ============ UTILITY METHODS ============\n   */\n\n  /**\n   * Actualiza el √≠ndice de documentos\n   */\n  updateDocumentIndex(key, metadata) {\n    try {\n      const index = this.loadFromLocalStorage('document_index') || [];\n      \n      const existingIndex = index.findIndex(item => item.key === key);\n      \n      if (existingIndex >= 0) {\n        index[existingIndex] = {\n          ...index[existingIndex],\n          ...metadata,\n          lastModified: new Date().toISOString()\n        };\n      } else {\n        index.push({\n          key: key,\n          ...metadata,\n          created: new Date().toISOString(),\n          lastModified: new Date().toISOString()\n        });\n      }\n      \n      this.saveToLocalStorage('document_index', index, {\n        title: '√çndice de documentos',\n        type: 'system_index'\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('‚ùå Error actualizando √≠ndice:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Elimina del √≠ndice de documentos\n   */\n  removeFromDocumentIndex(key) {\n    try {\n      const index = this.loadFromLocalStorage('document_index') || [];\n      const newIndex = index.filter(item => item.key !== key);\n      \n      this.saveToLocalStorage('document_index', newIndex, {\n        title: '√çndice de documentos',\n        type: 'system_index'\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('‚ùå Error eliminando del √≠ndice:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Obtiene todos los documentos\n   */\n  getAllDocuments() {\n    const index = this.loadFromLocalStorage('document_index') || [];\n    return index;\n  }\n\n  /**\n   * Maneja almacenamiento lleno\n   */\n  handleStorageFull() {\n    console.warn('‚ö†Ô∏è localStorage casi lleno, limpiando datos antiguos...');\n    \n    // Eliminar datos antiguos primero\n    this.cleanupOldData(true);\n    \n    // Si todav√≠a est√° lleno, eliminar versiones antiguas\n    const index = this.getAllDocuments();\n    const oldVersions = index.filter(item => \n      item.type === 'versions' && \n      item.lastModified && \n      new Date(item.lastModified) < new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30 d√≠as\n    );\n    \n    oldVersions.forEach(item => {\n      this.removeFromLocalStorage(item.key);\n    });\n    \n    console.log(`üóëÔ∏è ${oldVersions.length} versiones antiguas eliminadas`);\n  }\n\n  /**\n   * Limpia datos antiguos\n   */\n  cleanupOldData(force = false) {\n    const now = new Date();\n    const index = this.getAllDocuments();\n    let cleanedCount = 0;\n    \n    index.forEach(item => {\n      if (item.expiresAt) {\n        const expiresDate = new Date(item.expiresAt);\n        if (expiresDate < now || force) {\n          this.removeFromLocalStorage(item.key);\n          cleanedCount++;\n        }\n      }\n    });\n    \n    if (cleanedCount > 0) {\n      console.log(`üßπ ${cleanedCount} documentos expirados eliminados`);\n    }\n  }\n\n  /**\n   * Obtiene estad√≠sticas de almacenamiento\n   */\n  getStorageStats() {\n    let totalSize = 0;\n    const index = this.getAllDocuments();\n    \n    index.forEach(item => {\n      const data = this.loadFromLocalStorage(item.key);\n      if (data) {\n        totalSize += JSON.stringify(data).length;\n      }\n    });\n    \n    return {\n      totalDocuments: index.length,\n      totalSize: this.formatSize(totalSize),\n      localStorageUsage: this.formatSize(totalSize),\n      localStorageLimit: this.formatSize(this.MAX_LOCAL_STORAGE_SIZE),\n      usagePercentage: ((totalSize / this.MAX_LOCAL_STORAGE_SIZE) * 100).toFixed(2) + '%'\n    };\n  }\n\n  /**\n   * Formatea tama√±o en bytes a texto legible\n   */\n  formatSize(bytes) {\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n  }\n\n  /**\n   * Merge de documentos (estrategia simple)\n   */\n  mergeDocuments(doc1, doc2) {\n    // Estrategia simple: preferir doc2 sobre doc1\n    return {\n      ...doc1,\n      ...doc2,\n      metadata: {\n        ...doc1.metadata,\n        ...doc2.metadata,\n        mergedAt: new Date().toISOString()\n      }\n    };\n  }\n}\n\n/**\n * Instancia singleton del StorageService\n */\nlet storageServiceInstance = null;\n\n/**\n * Obtiene la instancia √∫nica del StorageService\n */\nexport function getStorageService() {\n  if (!storageServiceInstance) {\n    storageServiceInstance = new StorageService();\n    storageServiceInstance.initialize();\n  }\n  return storageServiceInstance;\n}\n\n/**\n * Utilidades de exportaci√≥n/importaci√≥n\n */\nexport const StorageUtils = {\n  /**\n   * Exporta todos los datos como archivo\n   */\n  async exportAllData() {\n    const service = getStorageService();\n    const backup = await service.createBackup();\n    \n    const blob = new Blob([JSON.stringify(backup, null, 2)], {\n      type: 'application/json'\n    });\n    \n    return {\n      blob: blob,\n      filename: `backup_documents_${new Date().toISOString().split('T')[0]}.json`,\n      stats: backup.metadata\n    };\n  },\n\n  /**\n   * Importa datos desde un archivo\n   */\n  async importFromFile(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = async (event) => {\n        try {\n          const backupData = JSON.parse(event.target.result);\n          const service = getStorageService();\n          const result = await service.restoreFromBackup(backupData);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('Error leyendo el archivo'));\n      };\n      \n      reader.readAsText(file);\n    });\n  },\n\n  /**\n   * Limpia todos los datos del sistema\n   */\n  async clearAllData() {\n    if (confirm('‚ö†Ô∏è ¬øEST√ÅS SEGURO? Esto eliminar√° TODOS los documentos y versiones. Esta acci√≥n NO se puede deshacer.')) {\n      const service = getStorageService();\n      const index = service.getAllDocuments();\n      \n      index.forEach(item => {\n        service.removeFromLocalStorage(item.key);\n      });\n      \n      localStorage.removeItem('document_index');\n      \n      return {\n        success: true,\n        cleared: index.length,\n        message: 'Todos los datos han sido eliminados'\n      };\n    }\n    \n    return {\n      success: false,\n      message: 'Operaci√≥n cancelada'\n    };\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}